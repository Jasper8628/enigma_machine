"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeAws_json1_1UpdateEndpointCommand = exports.deserializeAws_json1_1UntagResourceCommand = exports.deserializeAws_json1_1TagResourceCommand = exports.deserializeAws_json1_1StopTrainingEntityRecognizerCommand = exports.deserializeAws_json1_1StopTrainingDocumentClassifierCommand = exports.deserializeAws_json1_1StopSentimentDetectionJobCommand = exports.deserializeAws_json1_1StopKeyPhrasesDetectionJobCommand = exports.deserializeAws_json1_1StopEntitiesDetectionJobCommand = exports.deserializeAws_json1_1StopDominantLanguageDetectionJobCommand = exports.deserializeAws_json1_1StartTopicsDetectionJobCommand = exports.deserializeAws_json1_1StartSentimentDetectionJobCommand = exports.deserializeAws_json1_1StartKeyPhrasesDetectionJobCommand = exports.deserializeAws_json1_1StartEntitiesDetectionJobCommand = exports.deserializeAws_json1_1StartDominantLanguageDetectionJobCommand = exports.deserializeAws_json1_1StartDocumentClassificationJobCommand = exports.deserializeAws_json1_1ListTopicsDetectionJobsCommand = exports.deserializeAws_json1_1ListTagsForResourceCommand = exports.deserializeAws_json1_1ListSentimentDetectionJobsCommand = exports.deserializeAws_json1_1ListKeyPhrasesDetectionJobsCommand = exports.deserializeAws_json1_1ListEntityRecognizersCommand = exports.deserializeAws_json1_1ListEntitiesDetectionJobsCommand = exports.deserializeAws_json1_1ListEndpointsCommand = exports.deserializeAws_json1_1ListDominantLanguageDetectionJobsCommand = exports.deserializeAws_json1_1ListDocumentClassifiersCommand = exports.deserializeAws_json1_1ListDocumentClassificationJobsCommand = exports.deserializeAws_json1_1DetectSyntaxCommand = exports.deserializeAws_json1_1DetectSentimentCommand = exports.deserializeAws_json1_1DetectKeyPhrasesCommand = exports.deserializeAws_json1_1DetectEntitiesCommand = exports.deserializeAws_json1_1DetectDominantLanguageCommand = exports.deserializeAws_json1_1DescribeTopicsDetectionJobCommand = exports.deserializeAws_json1_1DescribeSentimentDetectionJobCommand = exports.deserializeAws_json1_1DescribeKeyPhrasesDetectionJobCommand = exports.deserializeAws_json1_1DescribeEntityRecognizerCommand = exports.deserializeAws_json1_1DescribeEntitiesDetectionJobCommand = exports.deserializeAws_json1_1DescribeEndpointCommand = exports.deserializeAws_json1_1DescribeDominantLanguageDetectionJobCommand = exports.deserializeAws_json1_1DescribeDocumentClassifierCommand = exports.deserializeAws_json1_1DescribeDocumentClassificationJobCommand = exports.deserializeAws_json1_1DeleteEntityRecognizerCommand = exports.deserializeAws_json1_1DeleteEndpointCommand = exports.deserializeAws_json1_1DeleteDocumentClassifierCommand = exports.deserializeAws_json1_1CreateEntityRecognizerCommand = exports.deserializeAws_json1_1CreateEndpointCommand = exports.deserializeAws_json1_1CreateDocumentClassifierCommand = exports.deserializeAws_json1_1ClassifyDocumentCommand = exports.deserializeAws_json1_1BatchDetectSyntaxCommand = exports.deserializeAws_json1_1BatchDetectSentimentCommand = exports.deserializeAws_json1_1BatchDetectKeyPhrasesCommand = exports.deserializeAws_json1_1BatchDetectEntitiesCommand = exports.deserializeAws_json1_1BatchDetectDominantLanguageCommand = exports.serializeAws_json1_1UpdateEndpointCommand = exports.serializeAws_json1_1UntagResourceCommand = exports.serializeAws_json1_1TagResourceCommand = exports.serializeAws_json1_1StopTrainingEntityRecognizerCommand = exports.serializeAws_json1_1StopTrainingDocumentClassifierCommand = exports.serializeAws_json1_1StopSentimentDetectionJobCommand = exports.serializeAws_json1_1StopKeyPhrasesDetectionJobCommand = exports.serializeAws_json1_1StopEntitiesDetectionJobCommand = exports.serializeAws_json1_1StopDominantLanguageDetectionJobCommand = exports.serializeAws_json1_1StartTopicsDetectionJobCommand = exports.serializeAws_json1_1StartSentimentDetectionJobCommand = exports.serializeAws_json1_1StartKeyPhrasesDetectionJobCommand = exports.serializeAws_json1_1StartEntitiesDetectionJobCommand = exports.serializeAws_json1_1StartDominantLanguageDetectionJobCommand = exports.serializeAws_json1_1StartDocumentClassificationJobCommand = exports.serializeAws_json1_1ListTopicsDetectionJobsCommand = exports.serializeAws_json1_1ListTagsForResourceCommand = exports.serializeAws_json1_1ListSentimentDetectionJobsCommand = exports.serializeAws_json1_1ListKeyPhrasesDetectionJobsCommand = exports.serializeAws_json1_1ListEntityRecognizersCommand = exports.serializeAws_json1_1ListEntitiesDetectionJobsCommand = exports.serializeAws_json1_1ListEndpointsCommand = exports.serializeAws_json1_1ListDominantLanguageDetectionJobsCommand = exports.serializeAws_json1_1ListDocumentClassifiersCommand = exports.serializeAws_json1_1ListDocumentClassificationJobsCommand = exports.serializeAws_json1_1DetectSyntaxCommand = exports.serializeAws_json1_1DetectSentimentCommand = exports.serializeAws_json1_1DetectKeyPhrasesCommand = exports.serializeAws_json1_1DetectEntitiesCommand = exports.serializeAws_json1_1DetectDominantLanguageCommand = exports.serializeAws_json1_1DescribeTopicsDetectionJobCommand = exports.serializeAws_json1_1DescribeSentimentDetectionJobCommand = exports.serializeAws_json1_1DescribeKeyPhrasesDetectionJobCommand = exports.serializeAws_json1_1DescribeEntityRecognizerCommand = exports.serializeAws_json1_1DescribeEntitiesDetectionJobCommand = exports.serializeAws_json1_1DescribeEndpointCommand = exports.serializeAws_json1_1DescribeDominantLanguageDetectionJobCommand = exports.serializeAws_json1_1DescribeDocumentClassifierCommand = exports.serializeAws_json1_1DescribeDocumentClassificationJobCommand = exports.serializeAws_json1_1DeleteEntityRecognizerCommand = exports.serializeAws_json1_1DeleteEndpointCommand = exports.serializeAws_json1_1DeleteDocumentClassifierCommand = exports.serializeAws_json1_1CreateEntityRecognizerCommand = exports.serializeAws_json1_1CreateEndpointCommand = exports.serializeAws_json1_1CreateDocumentClassifierCommand = exports.serializeAws_json1_1ClassifyDocumentCommand = exports.serializeAws_json1_1BatchDetectSyntaxCommand = exports.serializeAws_json1_1BatchDetectSentimentCommand = exports.serializeAws_json1_1BatchDetectKeyPhrasesCommand = exports.serializeAws_json1_1BatchDetectEntitiesCommand = exports.serializeAws_json1_1BatchDetectDominantLanguageCommand = void 0;
const protocol_http_1 = require("@aws-sdk/protocol-http");
const uuid_1 = require("uuid");
exports.serializeAws_json1_1BatchDetectDominantLanguageCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.BatchDetectDominantLanguage",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchDetectDominantLanguageRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1BatchDetectEntitiesCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.BatchDetectEntities",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchDetectEntitiesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1BatchDetectKeyPhrasesCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.BatchDetectKeyPhrases",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchDetectKeyPhrasesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1BatchDetectSentimentCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.BatchDetectSentiment",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchDetectSentimentRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1BatchDetectSyntaxCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.BatchDetectSyntax",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchDetectSyntaxRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ClassifyDocumentCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.ClassifyDocument",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ClassifyDocumentRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateDocumentClassifierCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.CreateDocumentClassifier",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateDocumentClassifierRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateEndpointCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.CreateEndpoint",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateEndpointRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateEntityRecognizerCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.CreateEntityRecognizer",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateEntityRecognizerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteDocumentClassifierCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DeleteDocumentClassifier",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteDocumentClassifierRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteEndpointCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DeleteEndpoint",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteEndpointRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteEntityRecognizerCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DeleteEntityRecognizer",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteEntityRecognizerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeDocumentClassificationJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DescribeDocumentClassificationJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeDocumentClassificationJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeDocumentClassifierCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DescribeDocumentClassifier",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeDocumentClassifierRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeDominantLanguageDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DescribeDominantLanguageDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeDominantLanguageDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeEndpointCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DescribeEndpoint",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeEndpointRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeEntitiesDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DescribeEntitiesDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeEntitiesDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeEntityRecognizerCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DescribeEntityRecognizer",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeEntityRecognizerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeKeyPhrasesDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DescribeKeyPhrasesDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeKeyPhrasesDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeSentimentDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DescribeSentimentDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeSentimentDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeTopicsDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DescribeTopicsDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeTopicsDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DetectDominantLanguageCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DetectDominantLanguage",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DetectDominantLanguageRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DetectEntitiesCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DetectEntities",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DetectEntitiesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DetectKeyPhrasesCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DetectKeyPhrases",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DetectKeyPhrasesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DetectSentimentCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DetectSentiment",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DetectSentimentRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DetectSyntaxCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.DetectSyntax",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DetectSyntaxRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListDocumentClassificationJobsCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.ListDocumentClassificationJobs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListDocumentClassificationJobsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListDocumentClassifiersCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.ListDocumentClassifiers",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListDocumentClassifiersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListDominantLanguageDetectionJobsCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.ListDominantLanguageDetectionJobs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListDominantLanguageDetectionJobsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListEndpointsCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.ListEndpoints",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListEndpointsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListEntitiesDetectionJobsCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.ListEntitiesDetectionJobs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListEntitiesDetectionJobsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListEntityRecognizersCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.ListEntityRecognizers",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListEntityRecognizersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListKeyPhrasesDetectionJobsCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.ListKeyPhrasesDetectionJobs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListKeyPhrasesDetectionJobsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListSentimentDetectionJobsCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.ListSentimentDetectionJobs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListSentimentDetectionJobsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListTagsForResourceCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.ListTagsForResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTagsForResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListTopicsDetectionJobsCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.ListTopicsDetectionJobs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTopicsDetectionJobsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartDocumentClassificationJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.StartDocumentClassificationJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartDocumentClassificationJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartDominantLanguageDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.StartDominantLanguageDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartDominantLanguageDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartEntitiesDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.StartEntitiesDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartEntitiesDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartKeyPhrasesDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.StartKeyPhrasesDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartKeyPhrasesDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartSentimentDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.StartSentimentDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartSentimentDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartTopicsDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.StartTopicsDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartTopicsDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StopDominantLanguageDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.StopDominantLanguageDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopDominantLanguageDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StopEntitiesDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.StopEntitiesDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopEntitiesDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StopKeyPhrasesDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.StopKeyPhrasesDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopKeyPhrasesDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StopSentimentDetectionJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.StopSentimentDetectionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopSentimentDetectionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StopTrainingDocumentClassifierCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.StopTrainingDocumentClassifier",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopTrainingDocumentClassifierRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StopTrainingEntityRecognizerCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.StopTrainingEntityRecognizer",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopTrainingEntityRecognizerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1TagResourceCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.TagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UntagResourceCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.UntagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UntagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateEndpointCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Comprehend_20171127.UpdateEndpoint",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateEndpointRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.deserializeAws_json1_1BatchDetectDominantLanguageCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1BatchDetectDominantLanguageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchDetectDominantLanguageResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "BatchDetectDominantLanguageResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchDetectDominantLanguageCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "BatchSizeLimitExceededException":
        case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextSizeLimitExceededException":
        case "com.amazonaws.comprehend#TextSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1BatchDetectEntitiesCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1BatchDetectEntitiesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchDetectEntitiesResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "BatchDetectEntitiesResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchDetectEntitiesCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "BatchSizeLimitExceededException":
        case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextSizeLimitExceededException":
        case "com.amazonaws.comprehend#TextSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedLanguageException":
        case "com.amazonaws.comprehend#UnsupportedLanguageException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1BatchDetectKeyPhrasesCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1BatchDetectKeyPhrasesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchDetectKeyPhrasesResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "BatchDetectKeyPhrasesResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchDetectKeyPhrasesCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "BatchSizeLimitExceededException":
        case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextSizeLimitExceededException":
        case "com.amazonaws.comprehend#TextSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedLanguageException":
        case "com.amazonaws.comprehend#UnsupportedLanguageException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1BatchDetectSentimentCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1BatchDetectSentimentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchDetectSentimentResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "BatchDetectSentimentResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchDetectSentimentCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "BatchSizeLimitExceededException":
        case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextSizeLimitExceededException":
        case "com.amazonaws.comprehend#TextSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedLanguageException":
        case "com.amazonaws.comprehend#UnsupportedLanguageException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1BatchDetectSyntaxCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1BatchDetectSyntaxCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchDetectSyntaxResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "BatchDetectSyntaxResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchDetectSyntaxCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "BatchSizeLimitExceededException":
        case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextSizeLimitExceededException":
        case "com.amazonaws.comprehend#TextSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedLanguageException":
        case "com.amazonaws.comprehend#UnsupportedLanguageException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ClassifyDocumentCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ClassifyDocumentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ClassifyDocumentResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ClassifyDocumentResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ClassifyDocumentCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceUnavailableException":
        case "com.amazonaws.comprehend#ResourceUnavailableException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceUnavailableExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextSizeLimitExceededException":
        case "com.amazonaws.comprehend#TextSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1CreateDocumentClassifierCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1CreateDocumentClassifierCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateDocumentClassifierResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateDocumentClassifierResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateDocumentClassifierCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "KmsKeyValidationException":
        case "com.amazonaws.comprehend#KmsKeyValidationException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1KmsKeyValidationExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceInUseException":
        case "com.amazonaws.comprehend#ResourceInUseException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceInUseExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceLimitExceededException":
        case "com.amazonaws.comprehend#ResourceLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyTagsException":
        case "com.amazonaws.comprehend#TooManyTagsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedLanguageException":
        case "com.amazonaws.comprehend#UnsupportedLanguageException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1CreateEndpointCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1CreateEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateEndpointResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateEndpointResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateEndpointCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceInUseException":
        case "com.amazonaws.comprehend#ResourceInUseException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceInUseExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceLimitExceededException":
        case "com.amazonaws.comprehend#ResourceLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceUnavailableException":
        case "com.amazonaws.comprehend#ResourceUnavailableException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceUnavailableExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyTagsException":
        case "com.amazonaws.comprehend#TooManyTagsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1CreateEntityRecognizerCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1CreateEntityRecognizerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateEntityRecognizerResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateEntityRecognizerResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateEntityRecognizerCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "KmsKeyValidationException":
        case "com.amazonaws.comprehend#KmsKeyValidationException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1KmsKeyValidationExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceInUseException":
        case "com.amazonaws.comprehend#ResourceInUseException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceInUseExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceLimitExceededException":
        case "com.amazonaws.comprehend#ResourceLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyTagsException":
        case "com.amazonaws.comprehend#TooManyTagsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedLanguageException":
        case "com.amazonaws.comprehend#UnsupportedLanguageException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DeleteDocumentClassifierCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DeleteDocumentClassifierCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteDocumentClassifierResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteDocumentClassifierResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteDocumentClassifierCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceInUseException":
        case "com.amazonaws.comprehend#ResourceInUseException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceInUseExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceUnavailableException":
        case "com.amazonaws.comprehend#ResourceUnavailableException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceUnavailableExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DeleteEndpointCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DeleteEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteEndpointResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteEndpointResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteEndpointCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceInUseException":
        case "com.amazonaws.comprehend#ResourceInUseException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceInUseExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DeleteEntityRecognizerCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DeleteEntityRecognizerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteEntityRecognizerResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteEntityRecognizerResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteEntityRecognizerCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceInUseException":
        case "com.amazonaws.comprehend#ResourceInUseException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceInUseExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceUnavailableException":
        case "com.amazonaws.comprehend#ResourceUnavailableException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceUnavailableExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DescribeDocumentClassificationJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DescribeDocumentClassificationJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeDocumentClassificationJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeDocumentClassificationJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DescribeDocumentClassificationJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "JobNotFoundException":
        case "com.amazonaws.comprehend#JobNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1JobNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DescribeDocumentClassifierCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DescribeDocumentClassifierCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeDocumentClassifierResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeDocumentClassifierResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DescribeDocumentClassifierCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DescribeDominantLanguageDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DescribeDominantLanguageDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeDominantLanguageDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeDominantLanguageDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DescribeDominantLanguageDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "JobNotFoundException":
        case "com.amazonaws.comprehend#JobNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1JobNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DescribeEndpointCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DescribeEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeEndpointResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeEndpointResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DescribeEndpointCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DescribeEntitiesDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DescribeEntitiesDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeEntitiesDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeEntitiesDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DescribeEntitiesDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "JobNotFoundException":
        case "com.amazonaws.comprehend#JobNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1JobNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DescribeEntityRecognizerCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DescribeEntityRecognizerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeEntityRecognizerResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeEntityRecognizerResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DescribeEntityRecognizerCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DescribeKeyPhrasesDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DescribeKeyPhrasesDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeKeyPhrasesDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeKeyPhrasesDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DescribeKeyPhrasesDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "JobNotFoundException":
        case "com.amazonaws.comprehend#JobNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1JobNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DescribeSentimentDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DescribeSentimentDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeSentimentDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeSentimentDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DescribeSentimentDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "JobNotFoundException":
        case "com.amazonaws.comprehend#JobNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1JobNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DescribeTopicsDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DescribeTopicsDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeTopicsDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeTopicsDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DescribeTopicsDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "JobNotFoundException":
        case "com.amazonaws.comprehend#JobNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1JobNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DetectDominantLanguageCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DetectDominantLanguageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DetectDominantLanguageResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DetectDominantLanguageResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DetectDominantLanguageCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextSizeLimitExceededException":
        case "com.amazonaws.comprehend#TextSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DetectEntitiesCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DetectEntitiesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DetectEntitiesResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DetectEntitiesResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DetectEntitiesCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceUnavailableException":
        case "com.amazonaws.comprehend#ResourceUnavailableException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceUnavailableExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextSizeLimitExceededException":
        case "com.amazonaws.comprehend#TextSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedLanguageException":
        case "com.amazonaws.comprehend#UnsupportedLanguageException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DetectKeyPhrasesCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DetectKeyPhrasesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DetectKeyPhrasesResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DetectKeyPhrasesResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DetectKeyPhrasesCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextSizeLimitExceededException":
        case "com.amazonaws.comprehend#TextSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedLanguageException":
        case "com.amazonaws.comprehend#UnsupportedLanguageException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DetectSentimentCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DetectSentimentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DetectSentimentResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DetectSentimentResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DetectSentimentCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextSizeLimitExceededException":
        case "com.amazonaws.comprehend#TextSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedLanguageException":
        case "com.amazonaws.comprehend#UnsupportedLanguageException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DetectSyntaxCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DetectSyntaxCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DetectSyntaxResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DetectSyntaxResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DetectSyntaxCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextSizeLimitExceededException":
        case "com.amazonaws.comprehend#TextSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedLanguageException":
        case "com.amazonaws.comprehend#UnsupportedLanguageException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ListDocumentClassificationJobsCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ListDocumentClassificationJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListDocumentClassificationJobsResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ListDocumentClassificationJobsResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListDocumentClassificationJobsCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidFilterException":
        case "com.amazonaws.comprehend#InvalidFilterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidFilterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ListDocumentClassifiersCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ListDocumentClassifiersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListDocumentClassifiersResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ListDocumentClassifiersResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListDocumentClassifiersCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidFilterException":
        case "com.amazonaws.comprehend#InvalidFilterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidFilterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ListDominantLanguageDetectionJobsCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ListDominantLanguageDetectionJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListDominantLanguageDetectionJobsResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ListDominantLanguageDetectionJobsResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListDominantLanguageDetectionJobsCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidFilterException":
        case "com.amazonaws.comprehend#InvalidFilterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidFilterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ListEndpointsCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ListEndpointsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListEndpointsResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ListEndpointsResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListEndpointsCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ListEntitiesDetectionJobsCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ListEntitiesDetectionJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListEntitiesDetectionJobsResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ListEntitiesDetectionJobsResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListEntitiesDetectionJobsCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidFilterException":
        case "com.amazonaws.comprehend#InvalidFilterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidFilterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ListEntityRecognizersCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ListEntityRecognizersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListEntityRecognizersResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ListEntityRecognizersResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListEntityRecognizersCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidFilterException":
        case "com.amazonaws.comprehend#InvalidFilterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidFilterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ListKeyPhrasesDetectionJobsCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ListKeyPhrasesDetectionJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListKeyPhrasesDetectionJobsResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ListKeyPhrasesDetectionJobsResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListKeyPhrasesDetectionJobsCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidFilterException":
        case "com.amazonaws.comprehend#InvalidFilterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidFilterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ListSentimentDetectionJobsCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ListSentimentDetectionJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListSentimentDetectionJobsResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ListSentimentDetectionJobsResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListSentimentDetectionJobsCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidFilterException":
        case "com.amazonaws.comprehend#InvalidFilterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidFilterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTagsForResourceResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ListTagsForResourceResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ListTopicsDetectionJobsCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ListTopicsDetectionJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTopicsDetectionJobsResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ListTopicsDetectionJobsResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListTopicsDetectionJobsCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidFilterException":
        case "com.amazonaws.comprehend#InvalidFilterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidFilterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StartDocumentClassificationJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StartDocumentClassificationJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartDocumentClassificationJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StartDocumentClassificationJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartDocumentClassificationJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "KmsKeyValidationException":
        case "com.amazonaws.comprehend#KmsKeyValidationException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1KmsKeyValidationExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceUnavailableException":
        case "com.amazonaws.comprehend#ResourceUnavailableException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceUnavailableExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StartDominantLanguageDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StartDominantLanguageDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartDominantLanguageDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StartDominantLanguageDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartDominantLanguageDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "KmsKeyValidationException":
        case "com.amazonaws.comprehend#KmsKeyValidationException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1KmsKeyValidationExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StartEntitiesDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StartEntitiesDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartEntitiesDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StartEntitiesDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartEntitiesDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "KmsKeyValidationException":
        case "com.amazonaws.comprehend#KmsKeyValidationException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1KmsKeyValidationExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceUnavailableException":
        case "com.amazonaws.comprehend#ResourceUnavailableException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceUnavailableExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StartKeyPhrasesDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StartKeyPhrasesDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartKeyPhrasesDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StartKeyPhrasesDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartKeyPhrasesDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "KmsKeyValidationException":
        case "com.amazonaws.comprehend#KmsKeyValidationException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1KmsKeyValidationExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StartSentimentDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StartSentimentDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartSentimentDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StartSentimentDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartSentimentDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "KmsKeyValidationException":
        case "com.amazonaws.comprehend#KmsKeyValidationException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1KmsKeyValidationExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StartTopicsDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StartTopicsDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartTopicsDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StartTopicsDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartTopicsDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "KmsKeyValidationException":
        case "com.amazonaws.comprehend#KmsKeyValidationException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1KmsKeyValidationExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StopDominantLanguageDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StopDominantLanguageDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopDominantLanguageDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StopDominantLanguageDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StopDominantLanguageDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "JobNotFoundException":
        case "com.amazonaws.comprehend#JobNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1JobNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StopEntitiesDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StopEntitiesDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopEntitiesDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StopEntitiesDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StopEntitiesDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "JobNotFoundException":
        case "com.amazonaws.comprehend#JobNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1JobNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StopKeyPhrasesDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StopKeyPhrasesDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopKeyPhrasesDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StopKeyPhrasesDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StopKeyPhrasesDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "JobNotFoundException":
        case "com.amazonaws.comprehend#JobNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1JobNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StopSentimentDetectionJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StopSentimentDetectionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopSentimentDetectionJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StopSentimentDetectionJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StopSentimentDetectionJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "JobNotFoundException":
        case "com.amazonaws.comprehend#JobNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1JobNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StopTrainingDocumentClassifierCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StopTrainingDocumentClassifierCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopTrainingDocumentClassifierResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StopTrainingDocumentClassifierResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StopTrainingDocumentClassifierCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StopTrainingEntityRecognizerCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StopTrainingEntityRecognizerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopTrainingEntityRecognizerResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StopTrainingEntityRecognizerResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StopTrainingEntityRecognizerCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1TagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1TagResourceResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "TagResourceResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1TagResourceCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.comprehend#ConcurrentModificationException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyTagsException":
        case "com.amazonaws.comprehend#TooManyTagsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1UntagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UntagResourceResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "UntagResourceResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1UntagResourceCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.comprehend#ConcurrentModificationException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyTagKeysException":
        case "com.amazonaws.comprehend#TooManyTagKeysException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyTagKeysExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1UpdateEndpointCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1UpdateEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateEndpointResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "UpdateEndpointResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateEndpointCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.comprehend#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.comprehend#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceInUseException":
        case "com.amazonaws.comprehend#ResourceInUseException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceInUseExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceLimitExceededException":
        case "com.amazonaws.comprehend#ResourceLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.comprehend#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceUnavailableException":
        case "com.amazonaws.comprehend#ResourceUnavailableException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceUnavailableExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.comprehend#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1BatchSizeLimitExceededException(body, context);
    const contents = Object.assign({ name: "BatchSizeLimitExceededException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1ConcurrentModificationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ConcurrentModificationException(body, context);
    const contents = Object.assign({ name: "ConcurrentModificationException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1InternalServerExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InternalServerException(body, context);
    const contents = Object.assign({ name: "InternalServerException", $fault: "server", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1InvalidFilterExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidFilterException(body, context);
    const contents = Object.assign({ name: "InvalidFilterException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1InvalidRequestExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidRequestException(body, context);
    const contents = Object.assign({ name: "InvalidRequestException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1JobNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1JobNotFoundException(body, context);
    const contents = Object.assign({ name: "JobNotFoundException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1KmsKeyValidationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1KmsKeyValidationException(body, context);
    const contents = Object.assign({ name: "KmsKeyValidationException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1ResourceInUseExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ResourceInUseException(body, context);
    const contents = Object.assign({ name: "ResourceInUseException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1ResourceLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ResourceLimitExceededException(body, context);
    const contents = Object.assign({ name: "ResourceLimitExceededException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ResourceNotFoundException(body, context);
    const contents = Object.assign({ name: "ResourceNotFoundException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1ResourceUnavailableExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ResourceUnavailableException(body, context);
    const contents = Object.assign({ name: "ResourceUnavailableException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1TextSizeLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TextSizeLimitExceededException(body, context);
    const contents = Object.assign({ name: "TextSizeLimitExceededException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1TooManyRequestsExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TooManyRequestsException(body, context);
    const contents = Object.assign({ name: "TooManyRequestsException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1TooManyTagKeysExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TooManyTagKeysException(body, context);
    const contents = Object.assign({ name: "TooManyTagKeysException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1TooManyTagsExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TooManyTagsException(body, context);
    const contents = Object.assign({ name: "TooManyTagsException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1UnsupportedLanguageExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1UnsupportedLanguageException(body, context);
    const contents = Object.assign({ name: "UnsupportedLanguageException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const serializeAws_json1_1BatchDetectDominantLanguageRequest = (input, context) => {
    return Object.assign({}, (input.TextList !== undefined && {
        TextList: serializeAws_json1_1CustomerInputStringList(input.TextList, context),
    }));
};
const serializeAws_json1_1BatchDetectEntitiesRequest = (input, context) => {
    return Object.assign(Object.assign({}, (input.LanguageCode !== undefined && { LanguageCode: input.LanguageCode })), (input.TextList !== undefined && {
        TextList: serializeAws_json1_1CustomerInputStringList(input.TextList, context),
    }));
};
const serializeAws_json1_1BatchDetectKeyPhrasesRequest = (input, context) => {
    return Object.assign(Object.assign({}, (input.LanguageCode !== undefined && { LanguageCode: input.LanguageCode })), (input.TextList !== undefined && {
        TextList: serializeAws_json1_1CustomerInputStringList(input.TextList, context),
    }));
};
const serializeAws_json1_1BatchDetectSentimentRequest = (input, context) => {
    return Object.assign(Object.assign({}, (input.LanguageCode !== undefined && { LanguageCode: input.LanguageCode })), (input.TextList !== undefined && {
        TextList: serializeAws_json1_1CustomerInputStringList(input.TextList, context),
    }));
};
const serializeAws_json1_1BatchDetectSyntaxRequest = (input, context) => {
    return Object.assign(Object.assign({}, (input.LanguageCode !== undefined && { LanguageCode: input.LanguageCode })), (input.TextList !== undefined && {
        TextList: serializeAws_json1_1CustomerInputStringList(input.TextList, context),
    }));
};
const serializeAws_json1_1ClassifyDocumentRequest = (input, context) => {
    return Object.assign(Object.assign({}, (input.EndpointArn !== undefined && { EndpointArn: input.EndpointArn })), (input.Text !== undefined && { Text: input.Text }));
};
const serializeAws_json1_1CreateDocumentClassifierRequest = (input, context) => {
    var _a;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4() }, (input.DataAccessRoleArn !== undefined && { DataAccessRoleArn: input.DataAccessRoleArn })), (input.DocumentClassifierName !== undefined && { DocumentClassifierName: input.DocumentClassifierName })), (input.InputDataConfig !== undefined && {
        InputDataConfig: serializeAws_json1_1DocumentClassifierInputDataConfig(input.InputDataConfig, context),
    })), (input.LanguageCode !== undefined && { LanguageCode: input.LanguageCode })), (input.Mode !== undefined && { Mode: input.Mode })), (input.OutputDataConfig !== undefined && {
        OutputDataConfig: serializeAws_json1_1DocumentClassifierOutputDataConfig(input.OutputDataConfig, context),
    })), (input.Tags !== undefined && { Tags: serializeAws_json1_1TagList(input.Tags, context) })), (input.VolumeKmsKeyId !== undefined && { VolumeKmsKeyId: input.VolumeKmsKeyId })), (input.VpcConfig !== undefined && { VpcConfig: serializeAws_json1_1VpcConfig(input.VpcConfig, context) }));
};
const serializeAws_json1_1CreateEndpointRequest = (input, context) => {
    var _a;
    return Object.assign(Object.assign(Object.assign(Object.assign({ ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4() }, (input.DesiredInferenceUnits !== undefined && { DesiredInferenceUnits: input.DesiredInferenceUnits })), (input.EndpointName !== undefined && { EndpointName: input.EndpointName })), (input.ModelArn !== undefined && { ModelArn: input.ModelArn })), (input.Tags !== undefined && { Tags: serializeAws_json1_1TagList(input.Tags, context) }));
};
const serializeAws_json1_1CreateEntityRecognizerRequest = (input, context) => {
    var _a;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4() }, (input.DataAccessRoleArn !== undefined && { DataAccessRoleArn: input.DataAccessRoleArn })), (input.InputDataConfig !== undefined && {
        InputDataConfig: serializeAws_json1_1EntityRecognizerInputDataConfig(input.InputDataConfig, context),
    })), (input.LanguageCode !== undefined && { LanguageCode: input.LanguageCode })), (input.RecognizerName !== undefined && { RecognizerName: input.RecognizerName })), (input.Tags !== undefined && { Tags: serializeAws_json1_1TagList(input.Tags, context) })), (input.VolumeKmsKeyId !== undefined && { VolumeKmsKeyId: input.VolumeKmsKeyId })), (input.VpcConfig !== undefined && { VpcConfig: serializeAws_json1_1VpcConfig(input.VpcConfig, context) }));
};
const serializeAws_json1_1CustomerInputStringList = (input, context) => {
    return input.map((entry) => entry);
};
const serializeAws_json1_1DeleteDocumentClassifierRequest = (input, context) => {
    return Object.assign({}, (input.DocumentClassifierArn !== undefined && { DocumentClassifierArn: input.DocumentClassifierArn }));
};
const serializeAws_json1_1DeleteEndpointRequest = (input, context) => {
    return Object.assign({}, (input.EndpointArn !== undefined && { EndpointArn: input.EndpointArn }));
};
const serializeAws_json1_1DeleteEntityRecognizerRequest = (input, context) => {
    return Object.assign({}, (input.EntityRecognizerArn !== undefined && { EntityRecognizerArn: input.EntityRecognizerArn }));
};
const serializeAws_json1_1DescribeDocumentClassificationJobRequest = (input, context) => {
    return Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId }));
};
const serializeAws_json1_1DescribeDocumentClassifierRequest = (input, context) => {
    return Object.assign({}, (input.DocumentClassifierArn !== undefined && { DocumentClassifierArn: input.DocumentClassifierArn }));
};
const serializeAws_json1_1DescribeDominantLanguageDetectionJobRequest = (input, context) => {
    return Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId }));
};
const serializeAws_json1_1DescribeEndpointRequest = (input, context) => {
    return Object.assign({}, (input.EndpointArn !== undefined && { EndpointArn: input.EndpointArn }));
};
const serializeAws_json1_1DescribeEntitiesDetectionJobRequest = (input, context) => {
    return Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId }));
};
const serializeAws_json1_1DescribeEntityRecognizerRequest = (input, context) => {
    return Object.assign({}, (input.EntityRecognizerArn !== undefined && { EntityRecognizerArn: input.EntityRecognizerArn }));
};
const serializeAws_json1_1DescribeKeyPhrasesDetectionJobRequest = (input, context) => {
    return Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId }));
};
const serializeAws_json1_1DescribeSentimentDetectionJobRequest = (input, context) => {
    return Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId }));
};
const serializeAws_json1_1DescribeTopicsDetectionJobRequest = (input, context) => {
    return Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId }));
};
const serializeAws_json1_1DetectDominantLanguageRequest = (input, context) => {
    return Object.assign({}, (input.Text !== undefined && { Text: input.Text }));
};
const serializeAws_json1_1DetectEntitiesRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.EndpointArn !== undefined && { EndpointArn: input.EndpointArn })), (input.LanguageCode !== undefined && { LanguageCode: input.LanguageCode })), (input.Text !== undefined && { Text: input.Text }));
};
const serializeAws_json1_1DetectKeyPhrasesRequest = (input, context) => {
    return Object.assign(Object.assign({}, (input.LanguageCode !== undefined && { LanguageCode: input.LanguageCode })), (input.Text !== undefined && { Text: input.Text }));
};
const serializeAws_json1_1DetectSentimentRequest = (input, context) => {
    return Object.assign(Object.assign({}, (input.LanguageCode !== undefined && { LanguageCode: input.LanguageCode })), (input.Text !== undefined && { Text: input.Text }));
};
const serializeAws_json1_1DetectSyntaxRequest = (input, context) => {
    return Object.assign(Object.assign({}, (input.LanguageCode !== undefined && { LanguageCode: input.LanguageCode })), (input.Text !== undefined && { Text: input.Text }));
};
const serializeAws_json1_1DocumentClassificationJobFilter = (input, context) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (input.JobName !== undefined && { JobName: input.JobName })), (input.JobStatus !== undefined && { JobStatus: input.JobStatus })), (input.SubmitTimeAfter !== undefined && { SubmitTimeAfter: Math.round(input.SubmitTimeAfter.getTime() / 1000) })), (input.SubmitTimeBefore !== undefined && {
        SubmitTimeBefore: Math.round(input.SubmitTimeBefore.getTime() / 1000),
    }));
};
const serializeAws_json1_1DocumentClassifierFilter = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Status !== undefined && { Status: input.Status })), (input.SubmitTimeAfter !== undefined && { SubmitTimeAfter: Math.round(input.SubmitTimeAfter.getTime() / 1000) })), (input.SubmitTimeBefore !== undefined && {
        SubmitTimeBefore: Math.round(input.SubmitTimeBefore.getTime() / 1000),
    }));
};
const serializeAws_json1_1DocumentClassifierInputDataConfig = (input, context) => {
    return Object.assign(Object.assign({}, (input.LabelDelimiter !== undefined && { LabelDelimiter: input.LabelDelimiter })), (input.S3Uri !== undefined && { S3Uri: input.S3Uri }));
};
const serializeAws_json1_1DocumentClassifierOutputDataConfig = (input, context) => {
    return Object.assign(Object.assign({}, (input.KmsKeyId !== undefined && { KmsKeyId: input.KmsKeyId })), (input.S3Uri !== undefined && { S3Uri: input.S3Uri }));
};
const serializeAws_json1_1DominantLanguageDetectionJobFilter = (input, context) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (input.JobName !== undefined && { JobName: input.JobName })), (input.JobStatus !== undefined && { JobStatus: input.JobStatus })), (input.SubmitTimeAfter !== undefined && { SubmitTimeAfter: Math.round(input.SubmitTimeAfter.getTime() / 1000) })), (input.SubmitTimeBefore !== undefined && {
        SubmitTimeBefore: Math.round(input.SubmitTimeBefore.getTime() / 1000),
    }));
};
const serializeAws_json1_1EndpointFilter = (input, context) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (input.CreationTimeAfter !== undefined && {
        CreationTimeAfter: Math.round(input.CreationTimeAfter.getTime() / 1000),
    })), (input.CreationTimeBefore !== undefined && {
        CreationTimeBefore: Math.round(input.CreationTimeBefore.getTime() / 1000),
    })), (input.ModelArn !== undefined && { ModelArn: input.ModelArn })), (input.Status !== undefined && { Status: input.Status }));
};
const serializeAws_json1_1EntitiesDetectionJobFilter = (input, context) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (input.JobName !== undefined && { JobName: input.JobName })), (input.JobStatus !== undefined && { JobStatus: input.JobStatus })), (input.SubmitTimeAfter !== undefined && { SubmitTimeAfter: Math.round(input.SubmitTimeAfter.getTime() / 1000) })), (input.SubmitTimeBefore !== undefined && {
        SubmitTimeBefore: Math.round(input.SubmitTimeBefore.getTime() / 1000),
    }));
};
const serializeAws_json1_1EntityRecognizerAnnotations = (input, context) => {
    return Object.assign({}, (input.S3Uri !== undefined && { S3Uri: input.S3Uri }));
};
const serializeAws_json1_1EntityRecognizerDocuments = (input, context) => {
    return Object.assign({}, (input.S3Uri !== undefined && { S3Uri: input.S3Uri }));
};
const serializeAws_json1_1EntityRecognizerEntityList = (input, context) => {
    return Object.assign({}, (input.S3Uri !== undefined && { S3Uri: input.S3Uri }));
};
const serializeAws_json1_1EntityRecognizerFilter = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Status !== undefined && { Status: input.Status })), (input.SubmitTimeAfter !== undefined && { SubmitTimeAfter: Math.round(input.SubmitTimeAfter.getTime() / 1000) })), (input.SubmitTimeBefore !== undefined && {
        SubmitTimeBefore: Math.round(input.SubmitTimeBefore.getTime() / 1000),
    }));
};
const serializeAws_json1_1EntityRecognizerInputDataConfig = (input, context) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (input.Annotations !== undefined && {
        Annotations: serializeAws_json1_1EntityRecognizerAnnotations(input.Annotations, context),
    })), (input.Documents !== undefined && {
        Documents: serializeAws_json1_1EntityRecognizerDocuments(input.Documents, context),
    })), (input.EntityList !== undefined && {
        EntityList: serializeAws_json1_1EntityRecognizerEntityList(input.EntityList, context),
    })), (input.EntityTypes !== undefined && {
        EntityTypes: serializeAws_json1_1EntityTypesList(input.EntityTypes, context),
    }));
};
const serializeAws_json1_1EntityTypesList = (input, context) => {
    return input.map((entry) => serializeAws_json1_1EntityTypesListItem(entry, context));
};
const serializeAws_json1_1EntityTypesListItem = (input, context) => {
    return Object.assign({}, (input.Type !== undefined && { Type: input.Type }));
};
const serializeAws_json1_1InputDataConfig = (input, context) => {
    return Object.assign(Object.assign({}, (input.InputFormat !== undefined && { InputFormat: input.InputFormat })), (input.S3Uri !== undefined && { S3Uri: input.S3Uri }));
};
const serializeAws_json1_1KeyPhrasesDetectionJobFilter = (input, context) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (input.JobName !== undefined && { JobName: input.JobName })), (input.JobStatus !== undefined && { JobStatus: input.JobStatus })), (input.SubmitTimeAfter !== undefined && { SubmitTimeAfter: Math.round(input.SubmitTimeAfter.getTime() / 1000) })), (input.SubmitTimeBefore !== undefined && {
        SubmitTimeBefore: Math.round(input.SubmitTimeBefore.getTime() / 1000),
    }));
};
const serializeAws_json1_1ListDocumentClassificationJobsRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Filter !== undefined && {
        Filter: serializeAws_json1_1DocumentClassificationJobFilter(input.Filter, context),
    })), (input.MaxResults !== undefined && { MaxResults: input.MaxResults })), (input.NextToken !== undefined && { NextToken: input.NextToken }));
};
const serializeAws_json1_1ListDocumentClassifiersRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Filter !== undefined && { Filter: serializeAws_json1_1DocumentClassifierFilter(input.Filter, context) })), (input.MaxResults !== undefined && { MaxResults: input.MaxResults })), (input.NextToken !== undefined && { NextToken: input.NextToken }));
};
const serializeAws_json1_1ListDominantLanguageDetectionJobsRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Filter !== undefined && {
        Filter: serializeAws_json1_1DominantLanguageDetectionJobFilter(input.Filter, context),
    })), (input.MaxResults !== undefined && { MaxResults: input.MaxResults })), (input.NextToken !== undefined && { NextToken: input.NextToken }));
};
const serializeAws_json1_1ListEndpointsRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Filter !== undefined && { Filter: serializeAws_json1_1EndpointFilter(input.Filter, context) })), (input.MaxResults !== undefined && { MaxResults: input.MaxResults })), (input.NextToken !== undefined && { NextToken: input.NextToken }));
};
const serializeAws_json1_1ListEntitiesDetectionJobsRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Filter !== undefined && {
        Filter: serializeAws_json1_1EntitiesDetectionJobFilter(input.Filter, context),
    })), (input.MaxResults !== undefined && { MaxResults: input.MaxResults })), (input.NextToken !== undefined && { NextToken: input.NextToken }));
};
const serializeAws_json1_1ListEntityRecognizersRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Filter !== undefined && { Filter: serializeAws_json1_1EntityRecognizerFilter(input.Filter, context) })), (input.MaxResults !== undefined && { MaxResults: input.MaxResults })), (input.NextToken !== undefined && { NextToken: input.NextToken }));
};
const serializeAws_json1_1ListKeyPhrasesDetectionJobsRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Filter !== undefined && {
        Filter: serializeAws_json1_1KeyPhrasesDetectionJobFilter(input.Filter, context),
    })), (input.MaxResults !== undefined && { MaxResults: input.MaxResults })), (input.NextToken !== undefined && { NextToken: input.NextToken }));
};
const serializeAws_json1_1ListSentimentDetectionJobsRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Filter !== undefined && {
        Filter: serializeAws_json1_1SentimentDetectionJobFilter(input.Filter, context),
    })), (input.MaxResults !== undefined && { MaxResults: input.MaxResults })), (input.NextToken !== undefined && { NextToken: input.NextToken }));
};
const serializeAws_json1_1ListTagsForResourceRequest = (input, context) => {
    return Object.assign({}, (input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }));
};
const serializeAws_json1_1ListTopicsDetectionJobsRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Filter !== undefined && { Filter: serializeAws_json1_1TopicsDetectionJobFilter(input.Filter, context) })), (input.MaxResults !== undefined && { MaxResults: input.MaxResults })), (input.NextToken !== undefined && { NextToken: input.NextToken }));
};
const serializeAws_json1_1OutputDataConfig = (input, context) => {
    return Object.assign(Object.assign({}, (input.KmsKeyId !== undefined && { KmsKeyId: input.KmsKeyId })), (input.S3Uri !== undefined && { S3Uri: input.S3Uri }));
};
const serializeAws_json1_1SecurityGroupIds = (input, context) => {
    return input.map((entry) => entry);
};
const serializeAws_json1_1SentimentDetectionJobFilter = (input, context) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (input.JobName !== undefined && { JobName: input.JobName })), (input.JobStatus !== undefined && { JobStatus: input.JobStatus })), (input.SubmitTimeAfter !== undefined && { SubmitTimeAfter: Math.round(input.SubmitTimeAfter.getTime() / 1000) })), (input.SubmitTimeBefore !== undefined && {
        SubmitTimeBefore: Math.round(input.SubmitTimeBefore.getTime() / 1000),
    }));
};
const serializeAws_json1_1StartDocumentClassificationJobRequest = (input, context) => {
    var _a;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4() }, (input.DataAccessRoleArn !== undefined && { DataAccessRoleArn: input.DataAccessRoleArn })), (input.DocumentClassifierArn !== undefined && { DocumentClassifierArn: input.DocumentClassifierArn })), (input.InputDataConfig !== undefined && {
        InputDataConfig: serializeAws_json1_1InputDataConfig(input.InputDataConfig, context),
    })), (input.JobName !== undefined && { JobName: input.JobName })), (input.OutputDataConfig !== undefined && {
        OutputDataConfig: serializeAws_json1_1OutputDataConfig(input.OutputDataConfig, context),
    })), (input.VolumeKmsKeyId !== undefined && { VolumeKmsKeyId: input.VolumeKmsKeyId })), (input.VpcConfig !== undefined && { VpcConfig: serializeAws_json1_1VpcConfig(input.VpcConfig, context) }));
};
const serializeAws_json1_1StartDominantLanguageDetectionJobRequest = (input, context) => {
    var _a;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4() }, (input.DataAccessRoleArn !== undefined && { DataAccessRoleArn: input.DataAccessRoleArn })), (input.InputDataConfig !== undefined && {
        InputDataConfig: serializeAws_json1_1InputDataConfig(input.InputDataConfig, context),
    })), (input.JobName !== undefined && { JobName: input.JobName })), (input.OutputDataConfig !== undefined && {
        OutputDataConfig: serializeAws_json1_1OutputDataConfig(input.OutputDataConfig, context),
    })), (input.VolumeKmsKeyId !== undefined && { VolumeKmsKeyId: input.VolumeKmsKeyId })), (input.VpcConfig !== undefined && { VpcConfig: serializeAws_json1_1VpcConfig(input.VpcConfig, context) }));
};
const serializeAws_json1_1StartEntitiesDetectionJobRequest = (input, context) => {
    var _a;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4() }, (input.DataAccessRoleArn !== undefined && { DataAccessRoleArn: input.DataAccessRoleArn })), (input.EntityRecognizerArn !== undefined && { EntityRecognizerArn: input.EntityRecognizerArn })), (input.InputDataConfig !== undefined && {
        InputDataConfig: serializeAws_json1_1InputDataConfig(input.InputDataConfig, context),
    })), (input.JobName !== undefined && { JobName: input.JobName })), (input.LanguageCode !== undefined && { LanguageCode: input.LanguageCode })), (input.OutputDataConfig !== undefined && {
        OutputDataConfig: serializeAws_json1_1OutputDataConfig(input.OutputDataConfig, context),
    })), (input.VolumeKmsKeyId !== undefined && { VolumeKmsKeyId: input.VolumeKmsKeyId })), (input.VpcConfig !== undefined && { VpcConfig: serializeAws_json1_1VpcConfig(input.VpcConfig, context) }));
};
const serializeAws_json1_1StartKeyPhrasesDetectionJobRequest = (input, context) => {
    var _a;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4() }, (input.DataAccessRoleArn !== undefined && { DataAccessRoleArn: input.DataAccessRoleArn })), (input.InputDataConfig !== undefined && {
        InputDataConfig: serializeAws_json1_1InputDataConfig(input.InputDataConfig, context),
    })), (input.JobName !== undefined && { JobName: input.JobName })), (input.LanguageCode !== undefined && { LanguageCode: input.LanguageCode })), (input.OutputDataConfig !== undefined && {
        OutputDataConfig: serializeAws_json1_1OutputDataConfig(input.OutputDataConfig, context),
    })), (input.VolumeKmsKeyId !== undefined && { VolumeKmsKeyId: input.VolumeKmsKeyId })), (input.VpcConfig !== undefined && { VpcConfig: serializeAws_json1_1VpcConfig(input.VpcConfig, context) }));
};
const serializeAws_json1_1StartSentimentDetectionJobRequest = (input, context) => {
    var _a;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4() }, (input.DataAccessRoleArn !== undefined && { DataAccessRoleArn: input.DataAccessRoleArn })), (input.InputDataConfig !== undefined && {
        InputDataConfig: serializeAws_json1_1InputDataConfig(input.InputDataConfig, context),
    })), (input.JobName !== undefined && { JobName: input.JobName })), (input.LanguageCode !== undefined && { LanguageCode: input.LanguageCode })), (input.OutputDataConfig !== undefined && {
        OutputDataConfig: serializeAws_json1_1OutputDataConfig(input.OutputDataConfig, context),
    })), (input.VolumeKmsKeyId !== undefined && { VolumeKmsKeyId: input.VolumeKmsKeyId })), (input.VpcConfig !== undefined && { VpcConfig: serializeAws_json1_1VpcConfig(input.VpcConfig, context) }));
};
const serializeAws_json1_1StartTopicsDetectionJobRequest = (input, context) => {
    var _a;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4() }, (input.DataAccessRoleArn !== undefined && { DataAccessRoleArn: input.DataAccessRoleArn })), (input.InputDataConfig !== undefined && {
        InputDataConfig: serializeAws_json1_1InputDataConfig(input.InputDataConfig, context),
    })), (input.JobName !== undefined && { JobName: input.JobName })), (input.NumberOfTopics !== undefined && { NumberOfTopics: input.NumberOfTopics })), (input.OutputDataConfig !== undefined && {
        OutputDataConfig: serializeAws_json1_1OutputDataConfig(input.OutputDataConfig, context),
    })), (input.VolumeKmsKeyId !== undefined && { VolumeKmsKeyId: input.VolumeKmsKeyId })), (input.VpcConfig !== undefined && { VpcConfig: serializeAws_json1_1VpcConfig(input.VpcConfig, context) }));
};
const serializeAws_json1_1StopDominantLanguageDetectionJobRequest = (input, context) => {
    return Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId }));
};
const serializeAws_json1_1StopEntitiesDetectionJobRequest = (input, context) => {
    return Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId }));
};
const serializeAws_json1_1StopKeyPhrasesDetectionJobRequest = (input, context) => {
    return Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId }));
};
const serializeAws_json1_1StopSentimentDetectionJobRequest = (input, context) => {
    return Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId }));
};
const serializeAws_json1_1StopTrainingDocumentClassifierRequest = (input, context) => {
    return Object.assign({}, (input.DocumentClassifierArn !== undefined && { DocumentClassifierArn: input.DocumentClassifierArn }));
};
const serializeAws_json1_1StopTrainingEntityRecognizerRequest = (input, context) => {
    return Object.assign({}, (input.EntityRecognizerArn !== undefined && { EntityRecognizerArn: input.EntityRecognizerArn }));
};
const serializeAws_json1_1Subnets = (input, context) => {
    return input.map((entry) => entry);
};
const serializeAws_json1_1Tag = (input, context) => {
    return Object.assign(Object.assign({}, (input.Key !== undefined && { Key: input.Key })), (input.Value !== undefined && { Value: input.Value }));
};
const serializeAws_json1_1TagKeyList = (input, context) => {
    return input.map((entry) => entry);
};
const serializeAws_json1_1TagList = (input, context) => {
    return input.map((entry) => serializeAws_json1_1Tag(entry, context));
};
const serializeAws_json1_1TagResourceRequest = (input, context) => {
    return Object.assign(Object.assign({}, (input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn })), (input.Tags !== undefined && { Tags: serializeAws_json1_1TagList(input.Tags, context) }));
};
const serializeAws_json1_1TopicsDetectionJobFilter = (input, context) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (input.JobName !== undefined && { JobName: input.JobName })), (input.JobStatus !== undefined && { JobStatus: input.JobStatus })), (input.SubmitTimeAfter !== undefined && { SubmitTimeAfter: Math.round(input.SubmitTimeAfter.getTime() / 1000) })), (input.SubmitTimeBefore !== undefined && {
        SubmitTimeBefore: Math.round(input.SubmitTimeBefore.getTime() / 1000),
    }));
};
const serializeAws_json1_1UntagResourceRequest = (input, context) => {
    return Object.assign(Object.assign({}, (input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn })), (input.TagKeys !== undefined && { TagKeys: serializeAws_json1_1TagKeyList(input.TagKeys, context) }));
};
const serializeAws_json1_1UpdateEndpointRequest = (input, context) => {
    return Object.assign(Object.assign({}, (input.DesiredInferenceUnits !== undefined && { DesiredInferenceUnits: input.DesiredInferenceUnits })), (input.EndpointArn !== undefined && { EndpointArn: input.EndpointArn }));
};
const serializeAws_json1_1VpcConfig = (input, context) => {
    return Object.assign(Object.assign({}, (input.SecurityGroupIds !== undefined && {
        SecurityGroupIds: serializeAws_json1_1SecurityGroupIds(input.SecurityGroupIds, context),
    })), (input.Subnets !== undefined && { Subnets: serializeAws_json1_1Subnets(input.Subnets, context) }));
};
const deserializeAws_json1_1BatchDetectDominantLanguageItemResult = (output, context) => {
    return {
        __type: "BatchDetectDominantLanguageItemResult",
        Index: output.Index !== undefined && output.Index !== null ? output.Index : undefined,
        Languages: output.Languages !== undefined && output.Languages !== null
            ? deserializeAws_json1_1ListOfDominantLanguages(output.Languages, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchDetectDominantLanguageResponse = (output, context) => {
    return {
        __type: "BatchDetectDominantLanguageResponse",
        ErrorList: output.ErrorList !== undefined && output.ErrorList !== null
            ? deserializeAws_json1_1BatchItemErrorList(output.ErrorList, context)
            : undefined,
        ResultList: output.ResultList !== undefined && output.ResultList !== null
            ? deserializeAws_json1_1ListOfDetectDominantLanguageResult(output.ResultList, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchDetectEntitiesItemResult = (output, context) => {
    return {
        __type: "BatchDetectEntitiesItemResult",
        Entities: output.Entities !== undefined && output.Entities !== null
            ? deserializeAws_json1_1ListOfEntities(output.Entities, context)
            : undefined,
        Index: output.Index !== undefined && output.Index !== null ? output.Index : undefined,
    };
};
const deserializeAws_json1_1BatchDetectEntitiesResponse = (output, context) => {
    return {
        __type: "BatchDetectEntitiesResponse",
        ErrorList: output.ErrorList !== undefined && output.ErrorList !== null
            ? deserializeAws_json1_1BatchItemErrorList(output.ErrorList, context)
            : undefined,
        ResultList: output.ResultList !== undefined && output.ResultList !== null
            ? deserializeAws_json1_1ListOfDetectEntitiesResult(output.ResultList, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchDetectKeyPhrasesItemResult = (output, context) => {
    return {
        __type: "BatchDetectKeyPhrasesItemResult",
        Index: output.Index !== undefined && output.Index !== null ? output.Index : undefined,
        KeyPhrases: output.KeyPhrases !== undefined && output.KeyPhrases !== null
            ? deserializeAws_json1_1ListOfKeyPhrases(output.KeyPhrases, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchDetectKeyPhrasesResponse = (output, context) => {
    return {
        __type: "BatchDetectKeyPhrasesResponse",
        ErrorList: output.ErrorList !== undefined && output.ErrorList !== null
            ? deserializeAws_json1_1BatchItemErrorList(output.ErrorList, context)
            : undefined,
        ResultList: output.ResultList !== undefined && output.ResultList !== null
            ? deserializeAws_json1_1ListOfDetectKeyPhrasesResult(output.ResultList, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchDetectSentimentItemResult = (output, context) => {
    return {
        __type: "BatchDetectSentimentItemResult",
        Index: output.Index !== undefined && output.Index !== null ? output.Index : undefined,
        Sentiment: output.Sentiment !== undefined && output.Sentiment !== null ? output.Sentiment : undefined,
        SentimentScore: output.SentimentScore !== undefined && output.SentimentScore !== null
            ? deserializeAws_json1_1SentimentScore(output.SentimentScore, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchDetectSentimentResponse = (output, context) => {
    return {
        __type: "BatchDetectSentimentResponse",
        ErrorList: output.ErrorList !== undefined && output.ErrorList !== null
            ? deserializeAws_json1_1BatchItemErrorList(output.ErrorList, context)
            : undefined,
        ResultList: output.ResultList !== undefined && output.ResultList !== null
            ? deserializeAws_json1_1ListOfDetectSentimentResult(output.ResultList, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchDetectSyntaxItemResult = (output, context) => {
    return {
        __type: "BatchDetectSyntaxItemResult",
        Index: output.Index !== undefined && output.Index !== null ? output.Index : undefined,
        SyntaxTokens: output.SyntaxTokens !== undefined && output.SyntaxTokens !== null
            ? deserializeAws_json1_1ListOfSyntaxTokens(output.SyntaxTokens, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchDetectSyntaxResponse = (output, context) => {
    return {
        __type: "BatchDetectSyntaxResponse",
        ErrorList: output.ErrorList !== undefined && output.ErrorList !== null
            ? deserializeAws_json1_1BatchItemErrorList(output.ErrorList, context)
            : undefined,
        ResultList: output.ResultList !== undefined && output.ResultList !== null
            ? deserializeAws_json1_1ListOfDetectSyntaxResult(output.ResultList, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchItemError = (output, context) => {
    return {
        __type: "BatchItemError",
        ErrorCode: output.ErrorCode !== undefined && output.ErrorCode !== null ? output.ErrorCode : undefined,
        ErrorMessage: output.ErrorMessage !== undefined && output.ErrorMessage !== null ? output.ErrorMessage : undefined,
        Index: output.Index !== undefined && output.Index !== null ? output.Index : undefined,
    };
};
const deserializeAws_json1_1BatchItemErrorList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1BatchItemError(entry, context));
};
const deserializeAws_json1_1BatchSizeLimitExceededException = (output, context) => {
    return {
        __type: "BatchSizeLimitExceededException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1ClassifierEvaluationMetrics = (output, context) => {
    return {
        __type: "ClassifierEvaluationMetrics",
        Accuracy: output.Accuracy !== undefined && output.Accuracy !== null ? output.Accuracy : undefined,
        F1Score: output.F1Score !== undefined && output.F1Score !== null ? output.F1Score : undefined,
        HammingLoss: output.HammingLoss !== undefined && output.HammingLoss !== null ? output.HammingLoss : undefined,
        MicroF1Score: output.MicroF1Score !== undefined && output.MicroF1Score !== null ? output.MicroF1Score : undefined,
        MicroPrecision: output.MicroPrecision !== undefined && output.MicroPrecision !== null ? output.MicroPrecision : undefined,
        MicroRecall: output.MicroRecall !== undefined && output.MicroRecall !== null ? output.MicroRecall : undefined,
        Precision: output.Precision !== undefined && output.Precision !== null ? output.Precision : undefined,
        Recall: output.Recall !== undefined && output.Recall !== null ? output.Recall : undefined,
    };
};
const deserializeAws_json1_1ClassifierMetadata = (output, context) => {
    return {
        __type: "ClassifierMetadata",
        EvaluationMetrics: output.EvaluationMetrics !== undefined && output.EvaluationMetrics !== null
            ? deserializeAws_json1_1ClassifierEvaluationMetrics(output.EvaluationMetrics, context)
            : undefined,
        NumberOfLabels: output.NumberOfLabels !== undefined && output.NumberOfLabels !== null ? output.NumberOfLabels : undefined,
        NumberOfTestDocuments: output.NumberOfTestDocuments !== undefined && output.NumberOfTestDocuments !== null
            ? output.NumberOfTestDocuments
            : undefined,
        NumberOfTrainedDocuments: output.NumberOfTrainedDocuments !== undefined && output.NumberOfTrainedDocuments !== null
            ? output.NumberOfTrainedDocuments
            : undefined,
    };
};
const deserializeAws_json1_1ClassifyDocumentResponse = (output, context) => {
    return {
        __type: "ClassifyDocumentResponse",
        Classes: output.Classes !== undefined && output.Classes !== null
            ? deserializeAws_json1_1ListOfClasses(output.Classes, context)
            : undefined,
        Labels: output.Labels !== undefined && output.Labels !== null
            ? deserializeAws_json1_1ListOfLabels(output.Labels, context)
            : undefined,
    };
};
const deserializeAws_json1_1ConcurrentModificationException = (output, context) => {
    return {
        __type: "ConcurrentModificationException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1CreateDocumentClassifierResponse = (output, context) => {
    return {
        __type: "CreateDocumentClassifierResponse",
        DocumentClassifierArn: output.DocumentClassifierArn !== undefined && output.DocumentClassifierArn !== null
            ? output.DocumentClassifierArn
            : undefined,
    };
};
const deserializeAws_json1_1CreateEndpointResponse = (output, context) => {
    return {
        __type: "CreateEndpointResponse",
        EndpointArn: output.EndpointArn !== undefined && output.EndpointArn !== null ? output.EndpointArn : undefined,
    };
};
const deserializeAws_json1_1CreateEntityRecognizerResponse = (output, context) => {
    return {
        __type: "CreateEntityRecognizerResponse",
        EntityRecognizerArn: output.EntityRecognizerArn !== undefined && output.EntityRecognizerArn !== null
            ? output.EntityRecognizerArn
            : undefined,
    };
};
const deserializeAws_json1_1DeleteDocumentClassifierResponse = (output, context) => {
    return {
        __type: "DeleteDocumentClassifierResponse",
    };
};
const deserializeAws_json1_1DeleteEndpointResponse = (output, context) => {
    return {
        __type: "DeleteEndpointResponse",
    };
};
const deserializeAws_json1_1DeleteEntityRecognizerResponse = (output, context) => {
    return {
        __type: "DeleteEntityRecognizerResponse",
    };
};
const deserializeAws_json1_1DescribeDocumentClassificationJobResponse = (output, context) => {
    return {
        __type: "DescribeDocumentClassificationJobResponse",
        DocumentClassificationJobProperties: output.DocumentClassificationJobProperties !== undefined && output.DocumentClassificationJobProperties !== null
            ? deserializeAws_json1_1DocumentClassificationJobProperties(output.DocumentClassificationJobProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1DescribeDocumentClassifierResponse = (output, context) => {
    return {
        __type: "DescribeDocumentClassifierResponse",
        DocumentClassifierProperties: output.DocumentClassifierProperties !== undefined && output.DocumentClassifierProperties !== null
            ? deserializeAws_json1_1DocumentClassifierProperties(output.DocumentClassifierProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1DescribeDominantLanguageDetectionJobResponse = (output, context) => {
    return {
        __type: "DescribeDominantLanguageDetectionJobResponse",
        DominantLanguageDetectionJobProperties: output.DominantLanguageDetectionJobProperties !== undefined &&
            output.DominantLanguageDetectionJobProperties !== null
            ? deserializeAws_json1_1DominantLanguageDetectionJobProperties(output.DominantLanguageDetectionJobProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1DescribeEndpointResponse = (output, context) => {
    return {
        __type: "DescribeEndpointResponse",
        EndpointProperties: output.EndpointProperties !== undefined && output.EndpointProperties !== null
            ? deserializeAws_json1_1EndpointProperties(output.EndpointProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1DescribeEntitiesDetectionJobResponse = (output, context) => {
    return {
        __type: "DescribeEntitiesDetectionJobResponse",
        EntitiesDetectionJobProperties: output.EntitiesDetectionJobProperties !== undefined && output.EntitiesDetectionJobProperties !== null
            ? deserializeAws_json1_1EntitiesDetectionJobProperties(output.EntitiesDetectionJobProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1DescribeEntityRecognizerResponse = (output, context) => {
    return {
        __type: "DescribeEntityRecognizerResponse",
        EntityRecognizerProperties: output.EntityRecognizerProperties !== undefined && output.EntityRecognizerProperties !== null
            ? deserializeAws_json1_1EntityRecognizerProperties(output.EntityRecognizerProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1DescribeKeyPhrasesDetectionJobResponse = (output, context) => {
    return {
        __type: "DescribeKeyPhrasesDetectionJobResponse",
        KeyPhrasesDetectionJobProperties: output.KeyPhrasesDetectionJobProperties !== undefined && output.KeyPhrasesDetectionJobProperties !== null
            ? deserializeAws_json1_1KeyPhrasesDetectionJobProperties(output.KeyPhrasesDetectionJobProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1DescribeSentimentDetectionJobResponse = (output, context) => {
    return {
        __type: "DescribeSentimentDetectionJobResponse",
        SentimentDetectionJobProperties: output.SentimentDetectionJobProperties !== undefined && output.SentimentDetectionJobProperties !== null
            ? deserializeAws_json1_1SentimentDetectionJobProperties(output.SentimentDetectionJobProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1DescribeTopicsDetectionJobResponse = (output, context) => {
    return {
        __type: "DescribeTopicsDetectionJobResponse",
        TopicsDetectionJobProperties: output.TopicsDetectionJobProperties !== undefined && output.TopicsDetectionJobProperties !== null
            ? deserializeAws_json1_1TopicsDetectionJobProperties(output.TopicsDetectionJobProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1DetectDominantLanguageResponse = (output, context) => {
    return {
        __type: "DetectDominantLanguageResponse",
        Languages: output.Languages !== undefined && output.Languages !== null
            ? deserializeAws_json1_1ListOfDominantLanguages(output.Languages, context)
            : undefined,
    };
};
const deserializeAws_json1_1DetectEntitiesResponse = (output, context) => {
    return {
        __type: "DetectEntitiesResponse",
        Entities: output.Entities !== undefined && output.Entities !== null
            ? deserializeAws_json1_1ListOfEntities(output.Entities, context)
            : undefined,
    };
};
const deserializeAws_json1_1DetectKeyPhrasesResponse = (output, context) => {
    return {
        __type: "DetectKeyPhrasesResponse",
        KeyPhrases: output.KeyPhrases !== undefined && output.KeyPhrases !== null
            ? deserializeAws_json1_1ListOfKeyPhrases(output.KeyPhrases, context)
            : undefined,
    };
};
const deserializeAws_json1_1DetectSentimentResponse = (output, context) => {
    return {
        __type: "DetectSentimentResponse",
        Sentiment: output.Sentiment !== undefined && output.Sentiment !== null ? output.Sentiment : undefined,
        SentimentScore: output.SentimentScore !== undefined && output.SentimentScore !== null
            ? deserializeAws_json1_1SentimentScore(output.SentimentScore, context)
            : undefined,
    };
};
const deserializeAws_json1_1DetectSyntaxResponse = (output, context) => {
    return {
        __type: "DetectSyntaxResponse",
        SyntaxTokens: output.SyntaxTokens !== undefined && output.SyntaxTokens !== null
            ? deserializeAws_json1_1ListOfSyntaxTokens(output.SyntaxTokens, context)
            : undefined,
    };
};
const deserializeAws_json1_1DocumentClass = (output, context) => {
    return {
        __type: "DocumentClass",
        Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
        Score: output.Score !== undefined && output.Score !== null ? output.Score : undefined,
    };
};
const deserializeAws_json1_1DocumentClassificationJobProperties = (output, context) => {
    return {
        __type: "DocumentClassificationJobProperties",
        DataAccessRoleArn: output.DataAccessRoleArn !== undefined && output.DataAccessRoleArn !== null
            ? output.DataAccessRoleArn
            : undefined,
        DocumentClassifierArn: output.DocumentClassifierArn !== undefined && output.DocumentClassifierArn !== null
            ? output.DocumentClassifierArn
            : undefined,
        EndTime: output.EndTime !== undefined && output.EndTime !== null ? new Date(Math.round(output.EndTime * 1000)) : undefined,
        InputDataConfig: output.InputDataConfig !== undefined && output.InputDataConfig !== null
            ? deserializeAws_json1_1InputDataConfig(output.InputDataConfig, context)
            : undefined,
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
        OutputDataConfig: output.OutputDataConfig !== undefined && output.OutputDataConfig !== null
            ? deserializeAws_json1_1OutputDataConfig(output.OutputDataConfig, context)
            : undefined,
        SubmitTime: output.SubmitTime !== undefined && output.SubmitTime !== null
            ? new Date(Math.round(output.SubmitTime * 1000))
            : undefined,
        VolumeKmsKeyId: output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null ? output.VolumeKmsKeyId : undefined,
        VpcConfig: output.VpcConfig !== undefined && output.VpcConfig !== null
            ? deserializeAws_json1_1VpcConfig(output.VpcConfig, context)
            : undefined,
    };
};
const deserializeAws_json1_1DocumentClassificationJobPropertiesList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1DocumentClassificationJobProperties(entry, context));
};
const deserializeAws_json1_1DocumentClassifierInputDataConfig = (output, context) => {
    return {
        __type: "DocumentClassifierInputDataConfig",
        LabelDelimiter: output.LabelDelimiter !== undefined && output.LabelDelimiter !== null ? output.LabelDelimiter : undefined,
        S3Uri: output.S3Uri !== undefined && output.S3Uri !== null ? output.S3Uri : undefined,
    };
};
const deserializeAws_json1_1DocumentClassifierOutputDataConfig = (output, context) => {
    return {
        __type: "DocumentClassifierOutputDataConfig",
        KmsKeyId: output.KmsKeyId !== undefined && output.KmsKeyId !== null ? output.KmsKeyId : undefined,
        S3Uri: output.S3Uri !== undefined && output.S3Uri !== null ? output.S3Uri : undefined,
    };
};
const deserializeAws_json1_1DocumentClassifierProperties = (output, context) => {
    return {
        __type: "DocumentClassifierProperties",
        ClassifierMetadata: output.ClassifierMetadata !== undefined && output.ClassifierMetadata !== null
            ? deserializeAws_json1_1ClassifierMetadata(output.ClassifierMetadata, context)
            : undefined,
        DataAccessRoleArn: output.DataAccessRoleArn !== undefined && output.DataAccessRoleArn !== null
            ? output.DataAccessRoleArn
            : undefined,
        DocumentClassifierArn: output.DocumentClassifierArn !== undefined && output.DocumentClassifierArn !== null
            ? output.DocumentClassifierArn
            : undefined,
        EndTime: output.EndTime !== undefined && output.EndTime !== null ? new Date(Math.round(output.EndTime * 1000)) : undefined,
        InputDataConfig: output.InputDataConfig !== undefined && output.InputDataConfig !== null
            ? deserializeAws_json1_1DocumentClassifierInputDataConfig(output.InputDataConfig, context)
            : undefined,
        LanguageCode: output.LanguageCode !== undefined && output.LanguageCode !== null ? output.LanguageCode : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
        Mode: output.Mode !== undefined && output.Mode !== null ? output.Mode : undefined,
        OutputDataConfig: output.OutputDataConfig !== undefined && output.OutputDataConfig !== null
            ? deserializeAws_json1_1DocumentClassifierOutputDataConfig(output.OutputDataConfig, context)
            : undefined,
        Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
        SubmitTime: output.SubmitTime !== undefined && output.SubmitTime !== null
            ? new Date(Math.round(output.SubmitTime * 1000))
            : undefined,
        TrainingEndTime: output.TrainingEndTime !== undefined && output.TrainingEndTime !== null
            ? new Date(Math.round(output.TrainingEndTime * 1000))
            : undefined,
        TrainingStartTime: output.TrainingStartTime !== undefined && output.TrainingStartTime !== null
            ? new Date(Math.round(output.TrainingStartTime * 1000))
            : undefined,
        VolumeKmsKeyId: output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null ? output.VolumeKmsKeyId : undefined,
        VpcConfig: output.VpcConfig !== undefined && output.VpcConfig !== null
            ? deserializeAws_json1_1VpcConfig(output.VpcConfig, context)
            : undefined,
    };
};
const deserializeAws_json1_1DocumentClassifierPropertiesList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1DocumentClassifierProperties(entry, context));
};
const deserializeAws_json1_1DocumentLabel = (output, context) => {
    return {
        __type: "DocumentLabel",
        Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
        Score: output.Score !== undefined && output.Score !== null ? output.Score : undefined,
    };
};
const deserializeAws_json1_1DominantLanguage = (output, context) => {
    return {
        __type: "DominantLanguage",
        LanguageCode: output.LanguageCode !== undefined && output.LanguageCode !== null ? output.LanguageCode : undefined,
        Score: output.Score !== undefined && output.Score !== null ? output.Score : undefined,
    };
};
const deserializeAws_json1_1DominantLanguageDetectionJobProperties = (output, context) => {
    return {
        __type: "DominantLanguageDetectionJobProperties",
        DataAccessRoleArn: output.DataAccessRoleArn !== undefined && output.DataAccessRoleArn !== null
            ? output.DataAccessRoleArn
            : undefined,
        EndTime: output.EndTime !== undefined && output.EndTime !== null ? new Date(Math.round(output.EndTime * 1000)) : undefined,
        InputDataConfig: output.InputDataConfig !== undefined && output.InputDataConfig !== null
            ? deserializeAws_json1_1InputDataConfig(output.InputDataConfig, context)
            : undefined,
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
        OutputDataConfig: output.OutputDataConfig !== undefined && output.OutputDataConfig !== null
            ? deserializeAws_json1_1OutputDataConfig(output.OutputDataConfig, context)
            : undefined,
        SubmitTime: output.SubmitTime !== undefined && output.SubmitTime !== null
            ? new Date(Math.round(output.SubmitTime * 1000))
            : undefined,
        VolumeKmsKeyId: output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null ? output.VolumeKmsKeyId : undefined,
        VpcConfig: output.VpcConfig !== undefined && output.VpcConfig !== null
            ? deserializeAws_json1_1VpcConfig(output.VpcConfig, context)
            : undefined,
    };
};
const deserializeAws_json1_1DominantLanguageDetectionJobPropertiesList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1DominantLanguageDetectionJobProperties(entry, context));
};
const deserializeAws_json1_1EndpointProperties = (output, context) => {
    return {
        __type: "EndpointProperties",
        CreationTime: output.CreationTime !== undefined && output.CreationTime !== null
            ? new Date(Math.round(output.CreationTime * 1000))
            : undefined,
        CurrentInferenceUnits: output.CurrentInferenceUnits !== undefined && output.CurrentInferenceUnits !== null
            ? output.CurrentInferenceUnits
            : undefined,
        DesiredInferenceUnits: output.DesiredInferenceUnits !== undefined && output.DesiredInferenceUnits !== null
            ? output.DesiredInferenceUnits
            : undefined,
        EndpointArn: output.EndpointArn !== undefined && output.EndpointArn !== null ? output.EndpointArn : undefined,
        LastModifiedTime: output.LastModifiedTime !== undefined && output.LastModifiedTime !== null
            ? new Date(Math.round(output.LastModifiedTime * 1000))
            : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
        ModelArn: output.ModelArn !== undefined && output.ModelArn !== null ? output.ModelArn : undefined,
        Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
    };
};
const deserializeAws_json1_1EndpointPropertiesList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1EndpointProperties(entry, context));
};
const deserializeAws_json1_1EntitiesDetectionJobProperties = (output, context) => {
    return {
        __type: "EntitiesDetectionJobProperties",
        DataAccessRoleArn: output.DataAccessRoleArn !== undefined && output.DataAccessRoleArn !== null
            ? output.DataAccessRoleArn
            : undefined,
        EndTime: output.EndTime !== undefined && output.EndTime !== null ? new Date(Math.round(output.EndTime * 1000)) : undefined,
        EntityRecognizerArn: output.EntityRecognizerArn !== undefined && output.EntityRecognizerArn !== null
            ? output.EntityRecognizerArn
            : undefined,
        InputDataConfig: output.InputDataConfig !== undefined && output.InputDataConfig !== null
            ? deserializeAws_json1_1InputDataConfig(output.InputDataConfig, context)
            : undefined,
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
        LanguageCode: output.LanguageCode !== undefined && output.LanguageCode !== null ? output.LanguageCode : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
        OutputDataConfig: output.OutputDataConfig !== undefined && output.OutputDataConfig !== null
            ? deserializeAws_json1_1OutputDataConfig(output.OutputDataConfig, context)
            : undefined,
        SubmitTime: output.SubmitTime !== undefined && output.SubmitTime !== null
            ? new Date(Math.round(output.SubmitTime * 1000))
            : undefined,
        VolumeKmsKeyId: output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null ? output.VolumeKmsKeyId : undefined,
        VpcConfig: output.VpcConfig !== undefined && output.VpcConfig !== null
            ? deserializeAws_json1_1VpcConfig(output.VpcConfig, context)
            : undefined,
    };
};
const deserializeAws_json1_1EntitiesDetectionJobPropertiesList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1EntitiesDetectionJobProperties(entry, context));
};
const deserializeAws_json1_1Entity = (output, context) => {
    return {
        __type: "Entity",
        BeginOffset: output.BeginOffset !== undefined && output.BeginOffset !== null ? output.BeginOffset : undefined,
        EndOffset: output.EndOffset !== undefined && output.EndOffset !== null ? output.EndOffset : undefined,
        Score: output.Score !== undefined && output.Score !== null ? output.Score : undefined,
        Text: output.Text !== undefined && output.Text !== null ? output.Text : undefined,
        Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
    };
};
const deserializeAws_json1_1EntityRecognizerAnnotations = (output, context) => {
    return {
        __type: "EntityRecognizerAnnotations",
        S3Uri: output.S3Uri !== undefined && output.S3Uri !== null ? output.S3Uri : undefined,
    };
};
const deserializeAws_json1_1EntityRecognizerDocuments = (output, context) => {
    return {
        __type: "EntityRecognizerDocuments",
        S3Uri: output.S3Uri !== undefined && output.S3Uri !== null ? output.S3Uri : undefined,
    };
};
const deserializeAws_json1_1EntityRecognizerEntityList = (output, context) => {
    return {
        __type: "EntityRecognizerEntityList",
        S3Uri: output.S3Uri !== undefined && output.S3Uri !== null ? output.S3Uri : undefined,
    };
};
const deserializeAws_json1_1EntityRecognizerEvaluationMetrics = (output, context) => {
    return {
        __type: "EntityRecognizerEvaluationMetrics",
        F1Score: output.F1Score !== undefined && output.F1Score !== null ? output.F1Score : undefined,
        Precision: output.Precision !== undefined && output.Precision !== null ? output.Precision : undefined,
        Recall: output.Recall !== undefined && output.Recall !== null ? output.Recall : undefined,
    };
};
const deserializeAws_json1_1EntityRecognizerInputDataConfig = (output, context) => {
    return {
        __type: "EntityRecognizerInputDataConfig",
        Annotations: output.Annotations !== undefined && output.Annotations !== null
            ? deserializeAws_json1_1EntityRecognizerAnnotations(output.Annotations, context)
            : undefined,
        Documents: output.Documents !== undefined && output.Documents !== null
            ? deserializeAws_json1_1EntityRecognizerDocuments(output.Documents, context)
            : undefined,
        EntityList: output.EntityList !== undefined && output.EntityList !== null
            ? deserializeAws_json1_1EntityRecognizerEntityList(output.EntityList, context)
            : undefined,
        EntityTypes: output.EntityTypes !== undefined && output.EntityTypes !== null
            ? deserializeAws_json1_1EntityTypesList(output.EntityTypes, context)
            : undefined,
    };
};
const deserializeAws_json1_1EntityRecognizerMetadata = (output, context) => {
    return {
        __type: "EntityRecognizerMetadata",
        EntityTypes: output.EntityTypes !== undefined && output.EntityTypes !== null
            ? deserializeAws_json1_1EntityRecognizerMetadataEntityTypesList(output.EntityTypes, context)
            : undefined,
        EvaluationMetrics: output.EvaluationMetrics !== undefined && output.EvaluationMetrics !== null
            ? deserializeAws_json1_1EntityRecognizerEvaluationMetrics(output.EvaluationMetrics, context)
            : undefined,
        NumberOfTestDocuments: output.NumberOfTestDocuments !== undefined && output.NumberOfTestDocuments !== null
            ? output.NumberOfTestDocuments
            : undefined,
        NumberOfTrainedDocuments: output.NumberOfTrainedDocuments !== undefined && output.NumberOfTrainedDocuments !== null
            ? output.NumberOfTrainedDocuments
            : undefined,
    };
};
const deserializeAws_json1_1EntityRecognizerMetadataEntityTypesList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1EntityRecognizerMetadataEntityTypesListItem(entry, context));
};
const deserializeAws_json1_1EntityRecognizerMetadataEntityTypesListItem = (output, context) => {
    return {
        __type: "EntityRecognizerMetadataEntityTypesListItem",
        EvaluationMetrics: output.EvaluationMetrics !== undefined && output.EvaluationMetrics !== null
            ? deserializeAws_json1_1EntityTypesEvaluationMetrics(output.EvaluationMetrics, context)
            : undefined,
        NumberOfTrainMentions: output.NumberOfTrainMentions !== undefined && output.NumberOfTrainMentions !== null
            ? output.NumberOfTrainMentions
            : undefined,
        Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
    };
};
const deserializeAws_json1_1EntityRecognizerProperties = (output, context) => {
    return {
        __type: "EntityRecognizerProperties",
        DataAccessRoleArn: output.DataAccessRoleArn !== undefined && output.DataAccessRoleArn !== null
            ? output.DataAccessRoleArn
            : undefined,
        EndTime: output.EndTime !== undefined && output.EndTime !== null ? new Date(Math.round(output.EndTime * 1000)) : undefined,
        EntityRecognizerArn: output.EntityRecognizerArn !== undefined && output.EntityRecognizerArn !== null
            ? output.EntityRecognizerArn
            : undefined,
        InputDataConfig: output.InputDataConfig !== undefined && output.InputDataConfig !== null
            ? deserializeAws_json1_1EntityRecognizerInputDataConfig(output.InputDataConfig, context)
            : undefined,
        LanguageCode: output.LanguageCode !== undefined && output.LanguageCode !== null ? output.LanguageCode : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
        RecognizerMetadata: output.RecognizerMetadata !== undefined && output.RecognizerMetadata !== null
            ? deserializeAws_json1_1EntityRecognizerMetadata(output.RecognizerMetadata, context)
            : undefined,
        Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
        SubmitTime: output.SubmitTime !== undefined && output.SubmitTime !== null
            ? new Date(Math.round(output.SubmitTime * 1000))
            : undefined,
        TrainingEndTime: output.TrainingEndTime !== undefined && output.TrainingEndTime !== null
            ? new Date(Math.round(output.TrainingEndTime * 1000))
            : undefined,
        TrainingStartTime: output.TrainingStartTime !== undefined && output.TrainingStartTime !== null
            ? new Date(Math.round(output.TrainingStartTime * 1000))
            : undefined,
        VolumeKmsKeyId: output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null ? output.VolumeKmsKeyId : undefined,
        VpcConfig: output.VpcConfig !== undefined && output.VpcConfig !== null
            ? deserializeAws_json1_1VpcConfig(output.VpcConfig, context)
            : undefined,
    };
};
const deserializeAws_json1_1EntityRecognizerPropertiesList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1EntityRecognizerProperties(entry, context));
};
const deserializeAws_json1_1EntityTypesEvaluationMetrics = (output, context) => {
    return {
        __type: "EntityTypesEvaluationMetrics",
        F1Score: output.F1Score !== undefined && output.F1Score !== null ? output.F1Score : undefined,
        Precision: output.Precision !== undefined && output.Precision !== null ? output.Precision : undefined,
        Recall: output.Recall !== undefined && output.Recall !== null ? output.Recall : undefined,
    };
};
const deserializeAws_json1_1EntityTypesList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1EntityTypesListItem(entry, context));
};
const deserializeAws_json1_1EntityTypesListItem = (output, context) => {
    return {
        __type: "EntityTypesListItem",
        Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
    };
};
const deserializeAws_json1_1InputDataConfig = (output, context) => {
    return {
        __type: "InputDataConfig",
        InputFormat: output.InputFormat !== undefined && output.InputFormat !== null ? output.InputFormat : undefined,
        S3Uri: output.S3Uri !== undefined && output.S3Uri !== null ? output.S3Uri : undefined,
    };
};
const deserializeAws_json1_1InternalServerException = (output, context) => {
    return {
        __type: "InternalServerException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1InvalidFilterException = (output, context) => {
    return {
        __type: "InvalidFilterException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1InvalidRequestException = (output, context) => {
    return {
        __type: "InvalidRequestException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1JobNotFoundException = (output, context) => {
    return {
        __type: "JobNotFoundException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1KeyPhrase = (output, context) => {
    return {
        __type: "KeyPhrase",
        BeginOffset: output.BeginOffset !== undefined && output.BeginOffset !== null ? output.BeginOffset : undefined,
        EndOffset: output.EndOffset !== undefined && output.EndOffset !== null ? output.EndOffset : undefined,
        Score: output.Score !== undefined && output.Score !== null ? output.Score : undefined,
        Text: output.Text !== undefined && output.Text !== null ? output.Text : undefined,
    };
};
const deserializeAws_json1_1KeyPhrasesDetectionJobProperties = (output, context) => {
    return {
        __type: "KeyPhrasesDetectionJobProperties",
        DataAccessRoleArn: output.DataAccessRoleArn !== undefined && output.DataAccessRoleArn !== null
            ? output.DataAccessRoleArn
            : undefined,
        EndTime: output.EndTime !== undefined && output.EndTime !== null ? new Date(Math.round(output.EndTime * 1000)) : undefined,
        InputDataConfig: output.InputDataConfig !== undefined && output.InputDataConfig !== null
            ? deserializeAws_json1_1InputDataConfig(output.InputDataConfig, context)
            : undefined,
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
        LanguageCode: output.LanguageCode !== undefined && output.LanguageCode !== null ? output.LanguageCode : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
        OutputDataConfig: output.OutputDataConfig !== undefined && output.OutputDataConfig !== null
            ? deserializeAws_json1_1OutputDataConfig(output.OutputDataConfig, context)
            : undefined,
        SubmitTime: output.SubmitTime !== undefined && output.SubmitTime !== null
            ? new Date(Math.round(output.SubmitTime * 1000))
            : undefined,
        VolumeKmsKeyId: output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null ? output.VolumeKmsKeyId : undefined,
        VpcConfig: output.VpcConfig !== undefined && output.VpcConfig !== null
            ? deserializeAws_json1_1VpcConfig(output.VpcConfig, context)
            : undefined,
    };
};
const deserializeAws_json1_1KeyPhrasesDetectionJobPropertiesList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1KeyPhrasesDetectionJobProperties(entry, context));
};
const deserializeAws_json1_1KmsKeyValidationException = (output, context) => {
    return {
        __type: "KmsKeyValidationException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1ListDocumentClassificationJobsResponse = (output, context) => {
    return {
        __type: "ListDocumentClassificationJobsResponse",
        DocumentClassificationJobPropertiesList: output.DocumentClassificationJobPropertiesList !== undefined &&
            output.DocumentClassificationJobPropertiesList !== null
            ? deserializeAws_json1_1DocumentClassificationJobPropertiesList(output.DocumentClassificationJobPropertiesList, context)
            : undefined,
        NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    };
};
const deserializeAws_json1_1ListDocumentClassifiersResponse = (output, context) => {
    return {
        __type: "ListDocumentClassifiersResponse",
        DocumentClassifierPropertiesList: output.DocumentClassifierPropertiesList !== undefined && output.DocumentClassifierPropertiesList !== null
            ? deserializeAws_json1_1DocumentClassifierPropertiesList(output.DocumentClassifierPropertiesList, context)
            : undefined,
        NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    };
};
const deserializeAws_json1_1ListDominantLanguageDetectionJobsResponse = (output, context) => {
    return {
        __type: "ListDominantLanguageDetectionJobsResponse",
        DominantLanguageDetectionJobPropertiesList: output.DominantLanguageDetectionJobPropertiesList !== undefined &&
            output.DominantLanguageDetectionJobPropertiesList !== null
            ? deserializeAws_json1_1DominantLanguageDetectionJobPropertiesList(output.DominantLanguageDetectionJobPropertiesList, context)
            : undefined,
        NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    };
};
const deserializeAws_json1_1ListEndpointsResponse = (output, context) => {
    return {
        __type: "ListEndpointsResponse",
        EndpointPropertiesList: output.EndpointPropertiesList !== undefined && output.EndpointPropertiesList !== null
            ? deserializeAws_json1_1EndpointPropertiesList(output.EndpointPropertiesList, context)
            : undefined,
        NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    };
};
const deserializeAws_json1_1ListEntitiesDetectionJobsResponse = (output, context) => {
    return {
        __type: "ListEntitiesDetectionJobsResponse",
        EntitiesDetectionJobPropertiesList: output.EntitiesDetectionJobPropertiesList !== undefined && output.EntitiesDetectionJobPropertiesList !== null
            ? deserializeAws_json1_1EntitiesDetectionJobPropertiesList(output.EntitiesDetectionJobPropertiesList, context)
            : undefined,
        NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    };
};
const deserializeAws_json1_1ListEntityRecognizersResponse = (output, context) => {
    return {
        __type: "ListEntityRecognizersResponse",
        EntityRecognizerPropertiesList: output.EntityRecognizerPropertiesList !== undefined && output.EntityRecognizerPropertiesList !== null
            ? deserializeAws_json1_1EntityRecognizerPropertiesList(output.EntityRecognizerPropertiesList, context)
            : undefined,
        NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    };
};
const deserializeAws_json1_1ListKeyPhrasesDetectionJobsResponse = (output, context) => {
    return {
        __type: "ListKeyPhrasesDetectionJobsResponse",
        KeyPhrasesDetectionJobPropertiesList: output.KeyPhrasesDetectionJobPropertiesList !== undefined && output.KeyPhrasesDetectionJobPropertiesList !== null
            ? deserializeAws_json1_1KeyPhrasesDetectionJobPropertiesList(output.KeyPhrasesDetectionJobPropertiesList, context)
            : undefined,
        NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    };
};
const deserializeAws_json1_1ListOfClasses = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1DocumentClass(entry, context));
};
const deserializeAws_json1_1ListOfDetectDominantLanguageResult = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1BatchDetectDominantLanguageItemResult(entry, context));
};
const deserializeAws_json1_1ListOfDetectEntitiesResult = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1BatchDetectEntitiesItemResult(entry, context));
};
const deserializeAws_json1_1ListOfDetectKeyPhrasesResult = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1BatchDetectKeyPhrasesItemResult(entry, context));
};
const deserializeAws_json1_1ListOfDetectSentimentResult = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1BatchDetectSentimentItemResult(entry, context));
};
const deserializeAws_json1_1ListOfDetectSyntaxResult = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1BatchDetectSyntaxItemResult(entry, context));
};
const deserializeAws_json1_1ListOfDominantLanguages = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1DominantLanguage(entry, context));
};
const deserializeAws_json1_1ListOfEntities = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1Entity(entry, context));
};
const deserializeAws_json1_1ListOfKeyPhrases = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1KeyPhrase(entry, context));
};
const deserializeAws_json1_1ListOfLabels = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1DocumentLabel(entry, context));
};
const deserializeAws_json1_1ListOfSyntaxTokens = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1SyntaxToken(entry, context));
};
const deserializeAws_json1_1ListSentimentDetectionJobsResponse = (output, context) => {
    return {
        __type: "ListSentimentDetectionJobsResponse",
        NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
        SentimentDetectionJobPropertiesList: output.SentimentDetectionJobPropertiesList !== undefined && output.SentimentDetectionJobPropertiesList !== null
            ? deserializeAws_json1_1SentimentDetectionJobPropertiesList(output.SentimentDetectionJobPropertiesList, context)
            : undefined,
    };
};
const deserializeAws_json1_1ListTagsForResourceResponse = (output, context) => {
    return {
        __type: "ListTagsForResourceResponse",
        ResourceArn: output.ResourceArn !== undefined && output.ResourceArn !== null ? output.ResourceArn : undefined,
        Tags: output.Tags !== undefined && output.Tags !== null
            ? deserializeAws_json1_1TagList(output.Tags, context)
            : undefined,
    };
};
const deserializeAws_json1_1ListTopicsDetectionJobsResponse = (output, context) => {
    return {
        __type: "ListTopicsDetectionJobsResponse",
        NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
        TopicsDetectionJobPropertiesList: output.TopicsDetectionJobPropertiesList !== undefined && output.TopicsDetectionJobPropertiesList !== null
            ? deserializeAws_json1_1TopicsDetectionJobPropertiesList(output.TopicsDetectionJobPropertiesList, context)
            : undefined,
    };
};
const deserializeAws_json1_1OutputDataConfig = (output, context) => {
    return {
        __type: "OutputDataConfig",
        KmsKeyId: output.KmsKeyId !== undefined && output.KmsKeyId !== null ? output.KmsKeyId : undefined,
        S3Uri: output.S3Uri !== undefined && output.S3Uri !== null ? output.S3Uri : undefined,
    };
};
const deserializeAws_json1_1PartOfSpeechTag = (output, context) => {
    return {
        __type: "PartOfSpeechTag",
        Score: output.Score !== undefined && output.Score !== null ? output.Score : undefined,
        Tag: output.Tag !== undefined && output.Tag !== null ? output.Tag : undefined,
    };
};
const deserializeAws_json1_1ResourceInUseException = (output, context) => {
    return {
        __type: "ResourceInUseException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1ResourceLimitExceededException = (output, context) => {
    return {
        __type: "ResourceLimitExceededException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1ResourceNotFoundException = (output, context) => {
    return {
        __type: "ResourceNotFoundException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1ResourceUnavailableException = (output, context) => {
    return {
        __type: "ResourceUnavailableException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1SecurityGroupIds = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_json1_1SentimentDetectionJobProperties = (output, context) => {
    return {
        __type: "SentimentDetectionJobProperties",
        DataAccessRoleArn: output.DataAccessRoleArn !== undefined && output.DataAccessRoleArn !== null
            ? output.DataAccessRoleArn
            : undefined,
        EndTime: output.EndTime !== undefined && output.EndTime !== null ? new Date(Math.round(output.EndTime * 1000)) : undefined,
        InputDataConfig: output.InputDataConfig !== undefined && output.InputDataConfig !== null
            ? deserializeAws_json1_1InputDataConfig(output.InputDataConfig, context)
            : undefined,
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
        LanguageCode: output.LanguageCode !== undefined && output.LanguageCode !== null ? output.LanguageCode : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
        OutputDataConfig: output.OutputDataConfig !== undefined && output.OutputDataConfig !== null
            ? deserializeAws_json1_1OutputDataConfig(output.OutputDataConfig, context)
            : undefined,
        SubmitTime: output.SubmitTime !== undefined && output.SubmitTime !== null
            ? new Date(Math.round(output.SubmitTime * 1000))
            : undefined,
        VolumeKmsKeyId: output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null ? output.VolumeKmsKeyId : undefined,
        VpcConfig: output.VpcConfig !== undefined && output.VpcConfig !== null
            ? deserializeAws_json1_1VpcConfig(output.VpcConfig, context)
            : undefined,
    };
};
const deserializeAws_json1_1SentimentDetectionJobPropertiesList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1SentimentDetectionJobProperties(entry, context));
};
const deserializeAws_json1_1SentimentScore = (output, context) => {
    return {
        __type: "SentimentScore",
        Mixed: output.Mixed !== undefined && output.Mixed !== null ? output.Mixed : undefined,
        Negative: output.Negative !== undefined && output.Negative !== null ? output.Negative : undefined,
        Neutral: output.Neutral !== undefined && output.Neutral !== null ? output.Neutral : undefined,
        Positive: output.Positive !== undefined && output.Positive !== null ? output.Positive : undefined,
    };
};
const deserializeAws_json1_1StartDocumentClassificationJobResponse = (output, context) => {
    return {
        __type: "StartDocumentClassificationJobResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
    };
};
const deserializeAws_json1_1StartDominantLanguageDetectionJobResponse = (output, context) => {
    return {
        __type: "StartDominantLanguageDetectionJobResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
    };
};
const deserializeAws_json1_1StartEntitiesDetectionJobResponse = (output, context) => {
    return {
        __type: "StartEntitiesDetectionJobResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
    };
};
const deserializeAws_json1_1StartKeyPhrasesDetectionJobResponse = (output, context) => {
    return {
        __type: "StartKeyPhrasesDetectionJobResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
    };
};
const deserializeAws_json1_1StartSentimentDetectionJobResponse = (output, context) => {
    return {
        __type: "StartSentimentDetectionJobResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
    };
};
const deserializeAws_json1_1StartTopicsDetectionJobResponse = (output, context) => {
    return {
        __type: "StartTopicsDetectionJobResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
    };
};
const deserializeAws_json1_1StopDominantLanguageDetectionJobResponse = (output, context) => {
    return {
        __type: "StopDominantLanguageDetectionJobResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
    };
};
const deserializeAws_json1_1StopEntitiesDetectionJobResponse = (output, context) => {
    return {
        __type: "StopEntitiesDetectionJobResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
    };
};
const deserializeAws_json1_1StopKeyPhrasesDetectionJobResponse = (output, context) => {
    return {
        __type: "StopKeyPhrasesDetectionJobResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
    };
};
const deserializeAws_json1_1StopSentimentDetectionJobResponse = (output, context) => {
    return {
        __type: "StopSentimentDetectionJobResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
    };
};
const deserializeAws_json1_1StopTrainingDocumentClassifierResponse = (output, context) => {
    return {
        __type: "StopTrainingDocumentClassifierResponse",
    };
};
const deserializeAws_json1_1StopTrainingEntityRecognizerResponse = (output, context) => {
    return {
        __type: "StopTrainingEntityRecognizerResponse",
    };
};
const deserializeAws_json1_1Subnets = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_json1_1SyntaxToken = (output, context) => {
    return {
        __type: "SyntaxToken",
        BeginOffset: output.BeginOffset !== undefined && output.BeginOffset !== null ? output.BeginOffset : undefined,
        EndOffset: output.EndOffset !== undefined && output.EndOffset !== null ? output.EndOffset : undefined,
        PartOfSpeech: output.PartOfSpeech !== undefined && output.PartOfSpeech !== null
            ? deserializeAws_json1_1PartOfSpeechTag(output.PartOfSpeech, context)
            : undefined,
        Text: output.Text !== undefined && output.Text !== null ? output.Text : undefined,
        TokenId: output.TokenId !== undefined && output.TokenId !== null ? output.TokenId : undefined,
    };
};
const deserializeAws_json1_1Tag = (output, context) => {
    return {
        __type: "Tag",
        Key: output.Key !== undefined && output.Key !== null ? output.Key : undefined,
        Value: output.Value !== undefined && output.Value !== null ? output.Value : undefined,
    };
};
const deserializeAws_json1_1TagList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1Tag(entry, context));
};
const deserializeAws_json1_1TagResourceResponse = (output, context) => {
    return {
        __type: "TagResourceResponse",
    };
};
const deserializeAws_json1_1TextSizeLimitExceededException = (output, context) => {
    return {
        __type: "TextSizeLimitExceededException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1TooManyRequestsException = (output, context) => {
    return {
        __type: "TooManyRequestsException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1TooManyTagKeysException = (output, context) => {
    return {
        __type: "TooManyTagKeysException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1TooManyTagsException = (output, context) => {
    return {
        __type: "TooManyTagsException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1TopicsDetectionJobProperties = (output, context) => {
    return {
        __type: "TopicsDetectionJobProperties",
        DataAccessRoleArn: output.DataAccessRoleArn !== undefined && output.DataAccessRoleArn !== null
            ? output.DataAccessRoleArn
            : undefined,
        EndTime: output.EndTime !== undefined && output.EndTime !== null ? new Date(Math.round(output.EndTime * 1000)) : undefined,
        InputDataConfig: output.InputDataConfig !== undefined && output.InputDataConfig !== null
            ? deserializeAws_json1_1InputDataConfig(output.InputDataConfig, context)
            : undefined,
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
        NumberOfTopics: output.NumberOfTopics !== undefined && output.NumberOfTopics !== null ? output.NumberOfTopics : undefined,
        OutputDataConfig: output.OutputDataConfig !== undefined && output.OutputDataConfig !== null
            ? deserializeAws_json1_1OutputDataConfig(output.OutputDataConfig, context)
            : undefined,
        SubmitTime: output.SubmitTime !== undefined && output.SubmitTime !== null
            ? new Date(Math.round(output.SubmitTime * 1000))
            : undefined,
        VolumeKmsKeyId: output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null ? output.VolumeKmsKeyId : undefined,
        VpcConfig: output.VpcConfig !== undefined && output.VpcConfig !== null
            ? deserializeAws_json1_1VpcConfig(output.VpcConfig, context)
            : undefined,
    };
};
const deserializeAws_json1_1TopicsDetectionJobPropertiesList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1TopicsDetectionJobProperties(entry, context));
};
const deserializeAws_json1_1UnsupportedLanguageException = (output, context) => {
    return {
        __type: "UnsupportedLanguageException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1UntagResourceResponse = (output, context) => {
    return {
        __type: "UntagResourceResponse",
    };
};
const deserializeAws_json1_1UpdateEndpointResponse = (output, context) => {
    return {
        __type: "UpdateEndpointResponse",
    };
};
const deserializeAws_json1_1VpcConfig = (output, context) => {
    return {
        __type: "VpcConfig",
        SecurityGroupIds: output.SecurityGroupIds !== undefined && output.SecurityGroupIds !== null
            ? deserializeAws_json1_1SecurityGroupIds(output.SecurityGroupIds, context)
            : undefined,
        Subnets: output.Subnets !== undefined && output.Subnets !== null
            ? deserializeAws_json1_1Subnets(output.Subnets, context)
            : undefined,
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    httpHeaders: output.headers,
    requestId: output.headers["x-amzn-requestid"],
});
// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
//# sourceMappingURL=Aws_json1_1.js.map