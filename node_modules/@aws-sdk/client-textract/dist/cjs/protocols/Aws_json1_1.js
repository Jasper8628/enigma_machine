"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeAws_json1_1StartDocumentTextDetectionCommand = exports.deserializeAws_json1_1StartDocumentAnalysisCommand = exports.deserializeAws_json1_1GetDocumentTextDetectionCommand = exports.deserializeAws_json1_1GetDocumentAnalysisCommand = exports.deserializeAws_json1_1DetectDocumentTextCommand = exports.deserializeAws_json1_1AnalyzeDocumentCommand = exports.serializeAws_json1_1StartDocumentTextDetectionCommand = exports.serializeAws_json1_1StartDocumentAnalysisCommand = exports.serializeAws_json1_1GetDocumentTextDetectionCommand = exports.serializeAws_json1_1GetDocumentAnalysisCommand = exports.serializeAws_json1_1DetectDocumentTextCommand = exports.serializeAws_json1_1AnalyzeDocumentCommand = void 0;
const protocol_http_1 = require("@aws-sdk/protocol-http");
const smithy_client_1 = require("@aws-sdk/smithy-client");
exports.serializeAws_json1_1AnalyzeDocumentCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Textract.AnalyzeDocument",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1AnalyzeDocumentRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DetectDocumentTextCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Textract.DetectDocumentText",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DetectDocumentTextRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetDocumentAnalysisCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Textract.GetDocumentAnalysis",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDocumentAnalysisRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetDocumentTextDetectionCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Textract.GetDocumentTextDetection",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDocumentTextDetectionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartDocumentAnalysisCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Textract.StartDocumentAnalysis",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartDocumentAnalysisRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartDocumentTextDetectionCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "Textract.StartDocumentTextDetection",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartDocumentTextDetectionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.deserializeAws_json1_1AnalyzeDocumentCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1AnalyzeDocumentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1AnalyzeDocumentResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AnalyzeDocumentResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1AnalyzeDocumentCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1BadDocumentExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1DocumentTooLargeExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "HumanLoopQuotaExceededException":
        case "com.amazonaws.textract#HumanLoopQuotaExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1HumanLoopQuotaExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerErrorResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidS3ObjectExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ProvisionedThroughputExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ThrottlingExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedDocumentExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DetectDocumentTextCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DetectDocumentTextCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DetectDocumentTextResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DetectDocumentTextResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DetectDocumentTextCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1BadDocumentExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1DocumentTooLargeExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerErrorResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidS3ObjectExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ProvisionedThroughputExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ThrottlingExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedDocumentExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1GetDocumentAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1GetDocumentAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDocumentAnalysisResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetDocumentAnalysisResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetDocumentAnalysisCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerErrorResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidJobIdException":
        case "com.amazonaws.textract#InvalidJobIdException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidJobIdExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ProvisionedThroughputExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ThrottlingExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1GetDocumentTextDetectionCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1GetDocumentTextDetectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDocumentTextDetectionResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetDocumentTextDetectionResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetDocumentTextDetectionCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerErrorResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidJobIdException":
        case "com.amazonaws.textract#InvalidJobIdException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidJobIdExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ProvisionedThroughputExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ThrottlingExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StartDocumentAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StartDocumentAnalysisCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartDocumentAnalysisResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StartDocumentAnalysisResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartDocumentAnalysisCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1BadDocumentExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1DocumentTooLargeExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerErrorResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidS3ObjectExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ProvisionedThroughputExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ThrottlingExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedDocumentExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StartDocumentTextDetectionCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StartDocumentTextDetectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartDocumentTextDetectionResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StartDocumentTextDetectionResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartDocumentTextDetectionCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.textract#AccessDeniedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "BadDocumentException":
        case "com.amazonaws.textract#BadDocumentException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1BadDocumentExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "DocumentTooLargeException":
        case "com.amazonaws.textract#DocumentTooLargeException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1DocumentTooLargeExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.textract#IdempotentParameterMismatchException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerError":
        case "com.amazonaws.textract#InternalServerError":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerErrorResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidParameterException":
        case "com.amazonaws.textract#InvalidParameterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidS3ObjectException":
        case "com.amazonaws.textract#InvalidS3ObjectException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidS3ObjectExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "LimitExceededException":
        case "com.amazonaws.textract#LimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ProvisionedThroughputExceededException":
        case "com.amazonaws.textract#ProvisionedThroughputExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ProvisionedThroughputExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ThrottlingException":
        case "com.amazonaws.textract#ThrottlingException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ThrottlingExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedDocumentException":
        case "com.amazonaws.textract#UnsupportedDocumentException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedDocumentExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1AccessDeniedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1AccessDeniedException(body, context);
    const contents = Object.assign({ name: "AccessDeniedException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1BadDocumentExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1BadDocumentException(body, context);
    const contents = Object.assign({ name: "BadDocumentException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1DocumentTooLargeExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DocumentTooLargeException(body, context);
    const contents = Object.assign({ name: "DocumentTooLargeException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1HumanLoopQuotaExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1HumanLoopQuotaExceededException(body, context);
    const contents = Object.assign({ name: "HumanLoopQuotaExceededException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1IdempotentParameterMismatchException(body, context);
    const contents = Object.assign({ name: "IdempotentParameterMismatchException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1InternalServerErrorResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InternalServerError(body, context);
    const contents = Object.assign({ name: "InternalServerError", $fault: "server", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1InvalidJobIdExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidJobIdException(body, context);
    const contents = Object.assign({ name: "InvalidJobIdException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1InvalidParameterExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidParameterException(body, context);
    const contents = Object.assign({ name: "InvalidParameterException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1InvalidS3ObjectExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidS3ObjectException(body, context);
    const contents = Object.assign({ name: "InvalidS3ObjectException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1LimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1LimitExceededException(body, context);
    const contents = Object.assign({ name: "LimitExceededException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1ProvisionedThroughputExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ProvisionedThroughputExceededException(body, context);
    const contents = Object.assign({ name: "ProvisionedThroughputExceededException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1ThrottlingExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ThrottlingException(body, context);
    const contents = Object.assign({ name: "ThrottlingException", $fault: "server", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1UnsupportedDocumentExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1UnsupportedDocumentException(body, context);
    const contents = Object.assign({ name: "UnsupportedDocumentException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const serializeAws_json1_1AnalyzeDocumentRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Document !== undefined && { Document: serializeAws_json1_1Document(input.Document, context) })), (input.FeatureTypes !== undefined && {
        FeatureTypes: serializeAws_json1_1FeatureTypes(input.FeatureTypes, context),
    })), (input.HumanLoopConfig !== undefined && {
        HumanLoopConfig: serializeAws_json1_1HumanLoopConfig(input.HumanLoopConfig, context),
    }));
};
const serializeAws_json1_1ContentClassifiers = (input, context) => {
    return input.map((entry) => entry);
};
const serializeAws_json1_1DetectDocumentTextRequest = (input, context) => {
    return Object.assign({}, (input.Document !== undefined && { Document: serializeAws_json1_1Document(input.Document, context) }));
};
const serializeAws_json1_1Document = (input, context) => {
    return Object.assign(Object.assign({}, (input.Bytes !== undefined && { Bytes: context.base64Encoder(input.Bytes) })), (input.S3Object !== undefined && { S3Object: serializeAws_json1_1S3Object(input.S3Object, context) }));
};
const serializeAws_json1_1DocumentLocation = (input, context) => {
    return Object.assign({}, (input.S3Object !== undefined && { S3Object: serializeAws_json1_1S3Object(input.S3Object, context) }));
};
const serializeAws_json1_1FeatureTypes = (input, context) => {
    return input.map((entry) => entry);
};
const serializeAws_json1_1GetDocumentAnalysisRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId })), (input.MaxResults !== undefined && { MaxResults: input.MaxResults })), (input.NextToken !== undefined && { NextToken: input.NextToken }));
};
const serializeAws_json1_1GetDocumentTextDetectionRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId })), (input.MaxResults !== undefined && { MaxResults: input.MaxResults })), (input.NextToken !== undefined && { NextToken: input.NextToken }));
};
const serializeAws_json1_1HumanLoopConfig = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.DataAttributes !== undefined && {
        DataAttributes: serializeAws_json1_1HumanLoopDataAttributes(input.DataAttributes, context),
    })), (input.FlowDefinitionArn !== undefined && { FlowDefinitionArn: input.FlowDefinitionArn })), (input.HumanLoopName !== undefined && { HumanLoopName: input.HumanLoopName }));
};
const serializeAws_json1_1HumanLoopDataAttributes = (input, context) => {
    return Object.assign({}, (input.ContentClassifiers !== undefined && {
        ContentClassifiers: serializeAws_json1_1ContentClassifiers(input.ContentClassifiers, context),
    }));
};
const serializeAws_json1_1NotificationChannel = (input, context) => {
    return Object.assign(Object.assign({}, (input.RoleArn !== undefined && { RoleArn: input.RoleArn })), (input.SNSTopicArn !== undefined && { SNSTopicArn: input.SNSTopicArn }));
};
const serializeAws_json1_1S3Object = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Bucket !== undefined && { Bucket: input.Bucket })), (input.Name !== undefined && { Name: input.Name })), (input.Version !== undefined && { Version: input.Version }));
};
const serializeAws_json1_1StartDocumentAnalysisRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (input.ClientRequestToken !== undefined && { ClientRequestToken: input.ClientRequestToken })), (input.DocumentLocation !== undefined && {
        DocumentLocation: serializeAws_json1_1DocumentLocation(input.DocumentLocation, context),
    })), (input.FeatureTypes !== undefined && {
        FeatureTypes: serializeAws_json1_1FeatureTypes(input.FeatureTypes, context),
    })), (input.JobTag !== undefined && { JobTag: input.JobTag })), (input.NotificationChannel !== undefined && {
        NotificationChannel: serializeAws_json1_1NotificationChannel(input.NotificationChannel, context),
    }));
};
const serializeAws_json1_1StartDocumentTextDetectionRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (input.ClientRequestToken !== undefined && { ClientRequestToken: input.ClientRequestToken })), (input.DocumentLocation !== undefined && {
        DocumentLocation: serializeAws_json1_1DocumentLocation(input.DocumentLocation, context),
    })), (input.JobTag !== undefined && { JobTag: input.JobTag })), (input.NotificationChannel !== undefined && {
        NotificationChannel: serializeAws_json1_1NotificationChannel(input.NotificationChannel, context),
    }));
};
const deserializeAws_json1_1AccessDeniedException = (output, context) => {
    return {
        __type: "AccessDeniedException",
        Code: output.Code !== undefined && output.Code !== null ? output.Code : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1AnalyzeDocumentResponse = (output, context) => {
    return {
        __type: "AnalyzeDocumentResponse",
        AnalyzeDocumentModelVersion: output.AnalyzeDocumentModelVersion !== undefined && output.AnalyzeDocumentModelVersion !== null
            ? output.AnalyzeDocumentModelVersion
            : undefined,
        Blocks: output.Blocks !== undefined && output.Blocks !== null
            ? deserializeAws_json1_1BlockList(output.Blocks, context)
            : undefined,
        DocumentMetadata: output.DocumentMetadata !== undefined && output.DocumentMetadata !== null
            ? deserializeAws_json1_1DocumentMetadata(output.DocumentMetadata, context)
            : undefined,
        HumanLoopActivationOutput: output.HumanLoopActivationOutput !== undefined && output.HumanLoopActivationOutput !== null
            ? deserializeAws_json1_1HumanLoopActivationOutput(output.HumanLoopActivationOutput, context)
            : undefined,
    };
};
const deserializeAws_json1_1BadDocumentException = (output, context) => {
    return {
        __type: "BadDocumentException",
        Code: output.Code !== undefined && output.Code !== null ? output.Code : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1Block = (output, context) => {
    return {
        __type: "Block",
        BlockType: output.BlockType !== undefined && output.BlockType !== null ? output.BlockType : undefined,
        ColumnIndex: output.ColumnIndex !== undefined && output.ColumnIndex !== null ? output.ColumnIndex : undefined,
        ColumnSpan: output.ColumnSpan !== undefined && output.ColumnSpan !== null ? output.ColumnSpan : undefined,
        Confidence: output.Confidence !== undefined && output.Confidence !== null ? output.Confidence : undefined,
        EntityTypes: output.EntityTypes !== undefined && output.EntityTypes !== null
            ? deserializeAws_json1_1EntityTypes(output.EntityTypes, context)
            : undefined,
        Geometry: output.Geometry !== undefined && output.Geometry !== null
            ? deserializeAws_json1_1Geometry(output.Geometry, context)
            : undefined,
        Id: output.Id !== undefined && output.Id !== null ? output.Id : undefined,
        Page: output.Page !== undefined && output.Page !== null ? output.Page : undefined,
        Relationships: output.Relationships !== undefined && output.Relationships !== null
            ? deserializeAws_json1_1RelationshipList(output.Relationships, context)
            : undefined,
        RowIndex: output.RowIndex !== undefined && output.RowIndex !== null ? output.RowIndex : undefined,
        RowSpan: output.RowSpan !== undefined && output.RowSpan !== null ? output.RowSpan : undefined,
        SelectionStatus: output.SelectionStatus !== undefined && output.SelectionStatus !== null ? output.SelectionStatus : undefined,
        Text: output.Text !== undefined && output.Text !== null ? output.Text : undefined,
    };
};
const deserializeAws_json1_1BlockList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1Block(entry, context));
};
const deserializeAws_json1_1BoundingBox = (output, context) => {
    return {
        __type: "BoundingBox",
        Height: output.Height !== undefined && output.Height !== null ? output.Height : undefined,
        Left: output.Left !== undefined && output.Left !== null ? output.Left : undefined,
        Top: output.Top !== undefined && output.Top !== null ? output.Top : undefined,
        Width: output.Width !== undefined && output.Width !== null ? output.Width : undefined,
    };
};
const deserializeAws_json1_1DetectDocumentTextResponse = (output, context) => {
    return {
        __type: "DetectDocumentTextResponse",
        Blocks: output.Blocks !== undefined && output.Blocks !== null
            ? deserializeAws_json1_1BlockList(output.Blocks, context)
            : undefined,
        DetectDocumentTextModelVersion: output.DetectDocumentTextModelVersion !== undefined && output.DetectDocumentTextModelVersion !== null
            ? output.DetectDocumentTextModelVersion
            : undefined,
        DocumentMetadata: output.DocumentMetadata !== undefined && output.DocumentMetadata !== null
            ? deserializeAws_json1_1DocumentMetadata(output.DocumentMetadata, context)
            : undefined,
    };
};
const deserializeAws_json1_1DocumentMetadata = (output, context) => {
    return {
        __type: "DocumentMetadata",
        Pages: output.Pages !== undefined && output.Pages !== null ? output.Pages : undefined,
    };
};
const deserializeAws_json1_1DocumentTooLargeException = (output, context) => {
    return {
        __type: "DocumentTooLargeException",
        Code: output.Code !== undefined && output.Code !== null ? output.Code : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1EntityTypes = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_json1_1Geometry = (output, context) => {
    return {
        __type: "Geometry",
        BoundingBox: output.BoundingBox !== undefined && output.BoundingBox !== null
            ? deserializeAws_json1_1BoundingBox(output.BoundingBox, context)
            : undefined,
        Polygon: output.Polygon !== undefined && output.Polygon !== null
            ? deserializeAws_json1_1Polygon(output.Polygon, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetDocumentAnalysisResponse = (output, context) => {
    return {
        __type: "GetDocumentAnalysisResponse",
        AnalyzeDocumentModelVersion: output.AnalyzeDocumentModelVersion !== undefined && output.AnalyzeDocumentModelVersion !== null
            ? output.AnalyzeDocumentModelVersion
            : undefined,
        Blocks: output.Blocks !== undefined && output.Blocks !== null
            ? deserializeAws_json1_1BlockList(output.Blocks, context)
            : undefined,
        DocumentMetadata: output.DocumentMetadata !== undefined && output.DocumentMetadata !== null
            ? deserializeAws_json1_1DocumentMetadata(output.DocumentMetadata, context)
            : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
        NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
        StatusMessage: output.StatusMessage !== undefined && output.StatusMessage !== null ? output.StatusMessage : undefined,
        Warnings: output.Warnings !== undefined && output.Warnings !== null
            ? deserializeAws_json1_1Warnings(output.Warnings, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetDocumentTextDetectionResponse = (output, context) => {
    return {
        __type: "GetDocumentTextDetectionResponse",
        Blocks: output.Blocks !== undefined && output.Blocks !== null
            ? deserializeAws_json1_1BlockList(output.Blocks, context)
            : undefined,
        DetectDocumentTextModelVersion: output.DetectDocumentTextModelVersion !== undefined && output.DetectDocumentTextModelVersion !== null
            ? output.DetectDocumentTextModelVersion
            : undefined,
        DocumentMetadata: output.DocumentMetadata !== undefined && output.DocumentMetadata !== null
            ? deserializeAws_json1_1DocumentMetadata(output.DocumentMetadata, context)
            : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
        NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
        StatusMessage: output.StatusMessage !== undefined && output.StatusMessage !== null ? output.StatusMessage : undefined,
        Warnings: output.Warnings !== undefined && output.Warnings !== null
            ? deserializeAws_json1_1Warnings(output.Warnings, context)
            : undefined,
    };
};
const deserializeAws_json1_1HumanLoopActivationOutput = (output, context) => {
    return {
        __type: "HumanLoopActivationOutput",
        HumanLoopActivationConditionsEvaluationResults: output.HumanLoopActivationConditionsEvaluationResults !== undefined &&
            output.HumanLoopActivationConditionsEvaluationResults !== null
            ? new smithy_client_1.LazyJsonString(output.HumanLoopActivationConditionsEvaluationResults)
            : undefined,
        HumanLoopActivationReasons: output.HumanLoopActivationReasons !== undefined && output.HumanLoopActivationReasons !== null
            ? deserializeAws_json1_1HumanLoopActivationReasons(output.HumanLoopActivationReasons, context)
            : undefined,
        HumanLoopArn: output.HumanLoopArn !== undefined && output.HumanLoopArn !== null ? output.HumanLoopArn : undefined,
    };
};
const deserializeAws_json1_1HumanLoopActivationReasons = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_json1_1HumanLoopQuotaExceededException = (output, context) => {
    return {
        __type: "HumanLoopQuotaExceededException",
        Code: output.Code !== undefined && output.Code !== null ? output.Code : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
        QuotaCode: output.QuotaCode !== undefined && output.QuotaCode !== null ? output.QuotaCode : undefined,
        ResourceType: output.ResourceType !== undefined && output.ResourceType !== null ? output.ResourceType : undefined,
        ServiceCode: output.ServiceCode !== undefined && output.ServiceCode !== null ? output.ServiceCode : undefined,
    };
};
const deserializeAws_json1_1IdempotentParameterMismatchException = (output, context) => {
    return {
        __type: "IdempotentParameterMismatchException",
        Code: output.Code !== undefined && output.Code !== null ? output.Code : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1IdList = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_json1_1InternalServerError = (output, context) => {
    return {
        __type: "InternalServerError",
        Code: output.Code !== undefined && output.Code !== null ? output.Code : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1InvalidJobIdException = (output, context) => {
    return {
        __type: "InvalidJobIdException",
        Code: output.Code !== undefined && output.Code !== null ? output.Code : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1InvalidParameterException = (output, context) => {
    return {
        __type: "InvalidParameterException",
        Code: output.Code !== undefined && output.Code !== null ? output.Code : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1InvalidS3ObjectException = (output, context) => {
    return {
        __type: "InvalidS3ObjectException",
        Code: output.Code !== undefined && output.Code !== null ? output.Code : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1LimitExceededException = (output, context) => {
    return {
        __type: "LimitExceededException",
        Code: output.Code !== undefined && output.Code !== null ? output.Code : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1Pages = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_json1_1Point = (output, context) => {
    return {
        __type: "Point",
        X: output.X !== undefined && output.X !== null ? output.X : undefined,
        Y: output.Y !== undefined && output.Y !== null ? output.Y : undefined,
    };
};
const deserializeAws_json1_1Polygon = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1Point(entry, context));
};
const deserializeAws_json1_1ProvisionedThroughputExceededException = (output, context) => {
    return {
        __type: "ProvisionedThroughputExceededException",
        Code: output.Code !== undefined && output.Code !== null ? output.Code : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1Relationship = (output, context) => {
    return {
        __type: "Relationship",
        Ids: output.Ids !== undefined && output.Ids !== null ? deserializeAws_json1_1IdList(output.Ids, context) : undefined,
        Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
    };
};
const deserializeAws_json1_1RelationshipList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1Relationship(entry, context));
};
const deserializeAws_json1_1StartDocumentAnalysisResponse = (output, context) => {
    return {
        __type: "StartDocumentAnalysisResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
    };
};
const deserializeAws_json1_1StartDocumentTextDetectionResponse = (output, context) => {
    return {
        __type: "StartDocumentTextDetectionResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
    };
};
const deserializeAws_json1_1ThrottlingException = (output, context) => {
    return {
        __type: "ThrottlingException",
        Code: output.Code !== undefined && output.Code !== null ? output.Code : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1UnsupportedDocumentException = (output, context) => {
    return {
        __type: "UnsupportedDocumentException",
        Code: output.Code !== undefined && output.Code !== null ? output.Code : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1Warning = (output, context) => {
    return {
        __type: "Warning",
        ErrorCode: output.ErrorCode !== undefined && output.ErrorCode !== null ? output.ErrorCode : undefined,
        Pages: output.Pages !== undefined && output.Pages !== null
            ? deserializeAws_json1_1Pages(output.Pages, context)
            : undefined,
    };
};
const deserializeAws_json1_1Warnings = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1Warning(entry, context));
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    httpHeaders: output.headers,
    requestId: output.headers["x-amzn-requestid"],
});
// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
//# sourceMappingURL=Aws_json1_1.js.map