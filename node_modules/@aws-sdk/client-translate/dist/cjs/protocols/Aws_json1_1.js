"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeAws_json1_1TranslateTextCommand = exports.deserializeAws_json1_1StopTextTranslationJobCommand = exports.deserializeAws_json1_1StartTextTranslationJobCommand = exports.deserializeAws_json1_1ListTextTranslationJobsCommand = exports.deserializeAws_json1_1ListTerminologiesCommand = exports.deserializeAws_json1_1ImportTerminologyCommand = exports.deserializeAws_json1_1GetTerminologyCommand = exports.deserializeAws_json1_1DescribeTextTranslationJobCommand = exports.deserializeAws_json1_1DeleteTerminologyCommand = exports.serializeAws_json1_1TranslateTextCommand = exports.serializeAws_json1_1StopTextTranslationJobCommand = exports.serializeAws_json1_1StartTextTranslationJobCommand = exports.serializeAws_json1_1ListTextTranslationJobsCommand = exports.serializeAws_json1_1ListTerminologiesCommand = exports.serializeAws_json1_1ImportTerminologyCommand = exports.serializeAws_json1_1GetTerminologyCommand = exports.serializeAws_json1_1DescribeTextTranslationJobCommand = exports.serializeAws_json1_1DeleteTerminologyCommand = void 0;
const protocol_http_1 = require("@aws-sdk/protocol-http");
const uuid_1 = require("uuid");
exports.serializeAws_json1_1DeleteTerminologyCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "AWSShineFrontendService_20170701.DeleteTerminology",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteTerminologyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeTextTranslationJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "AWSShineFrontendService_20170701.DescribeTextTranslationJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeTextTranslationJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetTerminologyCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "AWSShineFrontendService_20170701.GetTerminology",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetTerminologyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ImportTerminologyCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "AWSShineFrontendService_20170701.ImportTerminology",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ImportTerminologyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListTerminologiesCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "AWSShineFrontendService_20170701.ListTerminologies",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTerminologiesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListTextTranslationJobsCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "AWSShineFrontendService_20170701.ListTextTranslationJobs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTextTranslationJobsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartTextTranslationJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "AWSShineFrontendService_20170701.StartTextTranslationJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartTextTranslationJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StopTextTranslationJobCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "AWSShineFrontendService_20170701.StopTextTranslationJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopTextTranslationJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1TranslateTextCommand = async (input, context) => {
    const headers = {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "AWSShineFrontendService_20170701.TranslateText",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1TranslateTextRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.deserializeAws_json1_1DeleteTerminologyCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DeleteTerminologyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteTerminologyCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.translate#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.translate#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.translate#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1DescribeTextTranslationJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1DescribeTextTranslationJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeTextTranslationJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeTextTranslationJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1DescribeTextTranslationJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.translate#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.translate#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.translate#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1GetTerminologyCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1GetTerminologyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetTerminologyResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetTerminologyResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetTerminologyCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.translate#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidParameterValueException":
        case "com.amazonaws.translate#InvalidParameterValueException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidParameterValueExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.translate#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.translate#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ImportTerminologyCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ImportTerminologyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ImportTerminologyResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ImportTerminologyResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ImportTerminologyCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.translate#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidParameterValueException":
        case "com.amazonaws.translate#InvalidParameterValueException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidParameterValueExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "LimitExceededException":
        case "com.amazonaws.translate#LimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.translate#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ListTerminologiesCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ListTerminologiesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTerminologiesResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ListTerminologiesResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListTerminologiesCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.translate#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidParameterValueException":
        case "com.amazonaws.translate#InvalidParameterValueException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidParameterValueExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.translate#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1ListTextTranslationJobsCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1ListTextTranslationJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTextTranslationJobsResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ListTextTranslationJobsResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListTextTranslationJobsCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.translate#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidFilterException":
        case "com.amazonaws.translate#InvalidFilterException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidFilterExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.translate#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.translate#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StartTextTranslationJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StartTextTranslationJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartTextTranslationJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StartTextTranslationJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartTextTranslationJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.translate#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.translate#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.translate#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.translate#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedLanguagePairException":
        case "com.amazonaws.translate#UnsupportedLanguagePairException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedLanguagePairExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1StopTextTranslationJobCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1StopTextTranslationJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopTextTranslationJobResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StopTextTranslationJobResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1StopTextTranslationJobCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.translate#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.translate#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.translate#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
exports.deserializeAws_json1_1TranslateTextCommand = async (output, context) => {
    if (output.statusCode >= 400) {
        return deserializeAws_json1_1TranslateTextCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1TranslateTextResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "TranslateTextResponse" }, contents);
    return Promise.resolve(response);
};
const deserializeAws_json1_1TranslateTextCommandError = async (output, context) => {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    const errorTypeParts = parsedOutput.body["__type"].split("#");
    errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
    switch (errorCode) {
        case "DetectedLanguageLowConfidenceException":
        case "com.amazonaws.translate#DetectedLanguageLowConfidenceException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1DetectedLanguageLowConfidenceExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InternalServerException":
        case "com.amazonaws.translate#InternalServerException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InternalServerExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidRequestException":
        case "com.amazonaws.translate#InvalidRequestException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1InvalidRequestExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.translate#ResourceNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.translate#ServiceUnavailableException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextSizeLimitExceededException":
        case "com.amazonaws.translate#TextSizeLimitExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TooManyRequestsException":
        case "com.amazonaws.translate#TooManyRequestsException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedLanguagePairException":
        case "com.amazonaws.translate#UnsupportedLanguagePairException":
            response = Object.assign(Object.assign({}, (await deserializeAws_json1_1UnsupportedLanguagePairExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1DetectedLanguageLowConfidenceExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DetectedLanguageLowConfidenceException(body, context);
    const contents = Object.assign({ name: "DetectedLanguageLowConfidenceException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1InternalServerExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InternalServerException(body, context);
    const contents = Object.assign({ name: "InternalServerException", $fault: "server", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1InvalidFilterExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidFilterException(body, context);
    const contents = Object.assign({ name: "InvalidFilterException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1InvalidParameterValueExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidParameterValueException(body, context);
    const contents = Object.assign({ name: "InvalidParameterValueException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1InvalidRequestExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidRequestException(body, context);
    const contents = Object.assign({ name: "InvalidRequestException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1LimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1LimitExceededException(body, context);
    const contents = Object.assign({ name: "LimitExceededException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ResourceNotFoundException(body, context);
    const contents = Object.assign({ name: "ResourceNotFoundException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1ServiceUnavailableExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ServiceUnavailableException(body, context);
    const contents = Object.assign({ name: "ServiceUnavailableException", $fault: "server", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1TextSizeLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TextSizeLimitExceededException(body, context);
    const contents = Object.assign({ name: "TextSizeLimitExceededException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1TooManyRequestsExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TooManyRequestsException(body, context);
    const contents = Object.assign({ name: "TooManyRequestsException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const deserializeAws_json1_1UnsupportedLanguagePairExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1UnsupportedLanguagePairException(body, context);
    const contents = Object.assign({ name: "UnsupportedLanguagePairException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
    return contents;
};
const serializeAws_json1_1DeleteTerminologyRequest = (input, context) => {
    return Object.assign({}, (input.Name !== undefined && { Name: input.Name }));
};
const serializeAws_json1_1DescribeTextTranslationJobRequest = (input, context) => {
    return Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId }));
};
const serializeAws_json1_1EncryptionKey = (input, context) => {
    return Object.assign(Object.assign({}, (input.Id !== undefined && { Id: input.Id })), (input.Type !== undefined && { Type: input.Type }));
};
const serializeAws_json1_1GetTerminologyRequest = (input, context) => {
    return Object.assign(Object.assign({}, (input.Name !== undefined && { Name: input.Name })), (input.TerminologyDataFormat !== undefined && { TerminologyDataFormat: input.TerminologyDataFormat }));
};
const serializeAws_json1_1ImportTerminologyRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (input.Description !== undefined && { Description: input.Description })), (input.EncryptionKey !== undefined && {
        EncryptionKey: serializeAws_json1_1EncryptionKey(input.EncryptionKey, context),
    })), (input.MergeStrategy !== undefined && { MergeStrategy: input.MergeStrategy })), (input.Name !== undefined && { Name: input.Name })), (input.TerminologyData !== undefined && {
        TerminologyData: serializeAws_json1_1TerminologyData(input.TerminologyData, context),
    }));
};
const serializeAws_json1_1InputDataConfig = (input, context) => {
    return Object.assign(Object.assign({}, (input.ContentType !== undefined && { ContentType: input.ContentType })), (input.S3Uri !== undefined && { S3Uri: input.S3Uri }));
};
const serializeAws_json1_1ListTerminologiesRequest = (input, context) => {
    return Object.assign(Object.assign({}, (input.MaxResults !== undefined && { MaxResults: input.MaxResults })), (input.NextToken !== undefined && { NextToken: input.NextToken }));
};
const serializeAws_json1_1ListTextTranslationJobsRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign({}, (input.Filter !== undefined && { Filter: serializeAws_json1_1TextTranslationJobFilter(input.Filter, context) })), (input.MaxResults !== undefined && { MaxResults: input.MaxResults })), (input.NextToken !== undefined && { NextToken: input.NextToken }));
};
const serializeAws_json1_1OutputDataConfig = (input, context) => {
    return Object.assign({}, (input.S3Uri !== undefined && { S3Uri: input.S3Uri }));
};
const serializeAws_json1_1ResourceNameList = (input, context) => {
    return input.map((entry) => entry);
};
const serializeAws_json1_1StartTextTranslationJobRequest = (input, context) => {
    var _a;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ ClientToken: (_a = input.ClientToken) !== null && _a !== void 0 ? _a : uuid_1.v4() }, (input.DataAccessRoleArn !== undefined && { DataAccessRoleArn: input.DataAccessRoleArn })), (input.InputDataConfig !== undefined && {
        InputDataConfig: serializeAws_json1_1InputDataConfig(input.InputDataConfig, context),
    })), (input.JobName !== undefined && { JobName: input.JobName })), (input.OutputDataConfig !== undefined && {
        OutputDataConfig: serializeAws_json1_1OutputDataConfig(input.OutputDataConfig, context),
    })), (input.SourceLanguageCode !== undefined && { SourceLanguageCode: input.SourceLanguageCode })), (input.TargetLanguageCodes !== undefined && {
        TargetLanguageCodes: serializeAws_json1_1TargetLanguageCodeStringList(input.TargetLanguageCodes, context),
    })), (input.TerminologyNames !== undefined && {
        TerminologyNames: serializeAws_json1_1ResourceNameList(input.TerminologyNames, context),
    }));
};
const serializeAws_json1_1StopTextTranslationJobRequest = (input, context) => {
    return Object.assign({}, (input.JobId !== undefined && { JobId: input.JobId }));
};
const serializeAws_json1_1TargetLanguageCodeStringList = (input, context) => {
    return input.map((entry) => entry);
};
const serializeAws_json1_1TerminologyData = (input, context) => {
    return Object.assign(Object.assign({}, (input.File !== undefined && { File: context.base64Encoder(input.File) })), (input.Format !== undefined && { Format: input.Format }));
};
const serializeAws_json1_1TextTranslationJobFilter = (input, context) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (input.JobName !== undefined && { JobName: input.JobName })), (input.JobStatus !== undefined && { JobStatus: input.JobStatus })), (input.SubmittedAfterTime !== undefined && {
        SubmittedAfterTime: Math.round(input.SubmittedAfterTime.getTime() / 1000),
    })), (input.SubmittedBeforeTime !== undefined && {
        SubmittedBeforeTime: Math.round(input.SubmittedBeforeTime.getTime() / 1000),
    }));
};
const serializeAws_json1_1TranslateTextRequest = (input, context) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (input.SourceLanguageCode !== undefined && { SourceLanguageCode: input.SourceLanguageCode })), (input.TargetLanguageCode !== undefined && { TargetLanguageCode: input.TargetLanguageCode })), (input.TerminologyNames !== undefined && {
        TerminologyNames: serializeAws_json1_1ResourceNameList(input.TerminologyNames, context),
    })), (input.Text !== undefined && { Text: input.Text }));
};
const deserializeAws_json1_1AppliedTerminology = (output, context) => {
    return {
        __type: "AppliedTerminology",
        Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
        Terms: output.Terms !== undefined && output.Terms !== null
            ? deserializeAws_json1_1TermList(output.Terms, context)
            : undefined,
    };
};
const deserializeAws_json1_1AppliedTerminologyList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1AppliedTerminology(entry, context));
};
const deserializeAws_json1_1DescribeTextTranslationJobResponse = (output, context) => {
    return {
        __type: "DescribeTextTranslationJobResponse",
        TextTranslationJobProperties: output.TextTranslationJobProperties !== undefined && output.TextTranslationJobProperties !== null
            ? deserializeAws_json1_1TextTranslationJobProperties(output.TextTranslationJobProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1DetectedLanguageLowConfidenceException = (output, context) => {
    return {
        __type: "DetectedLanguageLowConfidenceException",
        DetectedLanguageCode: output.DetectedLanguageCode !== undefined && output.DetectedLanguageCode !== null
            ? output.DetectedLanguageCode
            : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1EncryptionKey = (output, context) => {
    return {
        __type: "EncryptionKey",
        Id: output.Id !== undefined && output.Id !== null ? output.Id : undefined,
        Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
    };
};
const deserializeAws_json1_1GetTerminologyResponse = (output, context) => {
    return {
        __type: "GetTerminologyResponse",
        TerminologyDataLocation: output.TerminologyDataLocation !== undefined && output.TerminologyDataLocation !== null
            ? deserializeAws_json1_1TerminologyDataLocation(output.TerminologyDataLocation, context)
            : undefined,
        TerminologyProperties: output.TerminologyProperties !== undefined && output.TerminologyProperties !== null
            ? deserializeAws_json1_1TerminologyProperties(output.TerminologyProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1ImportTerminologyResponse = (output, context) => {
    return {
        __type: "ImportTerminologyResponse",
        TerminologyProperties: output.TerminologyProperties !== undefined && output.TerminologyProperties !== null
            ? deserializeAws_json1_1TerminologyProperties(output.TerminologyProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1InputDataConfig = (output, context) => {
    return {
        __type: "InputDataConfig",
        ContentType: output.ContentType !== undefined && output.ContentType !== null ? output.ContentType : undefined,
        S3Uri: output.S3Uri !== undefined && output.S3Uri !== null ? output.S3Uri : undefined,
    };
};
const deserializeAws_json1_1InternalServerException = (output, context) => {
    return {
        __type: "InternalServerException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1InvalidFilterException = (output, context) => {
    return {
        __type: "InvalidFilterException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1InvalidParameterValueException = (output, context) => {
    return {
        __type: "InvalidParameterValueException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1InvalidRequestException = (output, context) => {
    return {
        __type: "InvalidRequestException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1JobDetails = (output, context) => {
    return {
        __type: "JobDetails",
        DocumentsWithErrorsCount: output.DocumentsWithErrorsCount !== undefined && output.DocumentsWithErrorsCount !== null
            ? output.DocumentsWithErrorsCount
            : undefined,
        InputDocumentsCount: output.InputDocumentsCount !== undefined && output.InputDocumentsCount !== null
            ? output.InputDocumentsCount
            : undefined,
        TranslatedDocumentsCount: output.TranslatedDocumentsCount !== undefined && output.TranslatedDocumentsCount !== null
            ? output.TranslatedDocumentsCount
            : undefined,
    };
};
const deserializeAws_json1_1LanguageCodeStringList = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_json1_1LimitExceededException = (output, context) => {
    return {
        __type: "LimitExceededException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1ListTerminologiesResponse = (output, context) => {
    return {
        __type: "ListTerminologiesResponse",
        NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
        TerminologyPropertiesList: output.TerminologyPropertiesList !== undefined && output.TerminologyPropertiesList !== null
            ? deserializeAws_json1_1TerminologyPropertiesList(output.TerminologyPropertiesList, context)
            : undefined,
    };
};
const deserializeAws_json1_1ListTextTranslationJobsResponse = (output, context) => {
    return {
        __type: "ListTextTranslationJobsResponse",
        NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
        TextTranslationJobPropertiesList: output.TextTranslationJobPropertiesList !== undefined && output.TextTranslationJobPropertiesList !== null
            ? deserializeAws_json1_1TextTranslationJobPropertiesList(output.TextTranslationJobPropertiesList, context)
            : undefined,
    };
};
const deserializeAws_json1_1OutputDataConfig = (output, context) => {
    return {
        __type: "OutputDataConfig",
        S3Uri: output.S3Uri !== undefined && output.S3Uri !== null ? output.S3Uri : undefined,
    };
};
const deserializeAws_json1_1ResourceNameList = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_json1_1ResourceNotFoundException = (output, context) => {
    return {
        __type: "ResourceNotFoundException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1ServiceUnavailableException = (output, context) => {
    return {
        __type: "ServiceUnavailableException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1StartTextTranslationJobResponse = (output, context) => {
    return {
        __type: "StartTextTranslationJobResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
    };
};
const deserializeAws_json1_1StopTextTranslationJobResponse = (output, context) => {
    return {
        __type: "StopTextTranslationJobResponse",
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
    };
};
const deserializeAws_json1_1TargetLanguageCodeStringList = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_json1_1Term = (output, context) => {
    return {
        __type: "Term",
        SourceText: output.SourceText !== undefined && output.SourceText !== null ? output.SourceText : undefined,
        TargetText: output.TargetText !== undefined && output.TargetText !== null ? output.TargetText : undefined,
    };
};
const deserializeAws_json1_1TerminologyDataLocation = (output, context) => {
    return {
        __type: "TerminologyDataLocation",
        Location: output.Location !== undefined && output.Location !== null ? output.Location : undefined,
        RepositoryType: output.RepositoryType !== undefined && output.RepositoryType !== null ? output.RepositoryType : undefined,
    };
};
const deserializeAws_json1_1TerminologyProperties = (output, context) => {
    return {
        __type: "TerminologyProperties",
        Arn: output.Arn !== undefined && output.Arn !== null ? output.Arn : undefined,
        CreatedAt: output.CreatedAt !== undefined && output.CreatedAt !== null
            ? new Date(Math.round(output.CreatedAt * 1000))
            : undefined,
        Description: output.Description !== undefined && output.Description !== null ? output.Description : undefined,
        EncryptionKey: output.EncryptionKey !== undefined && output.EncryptionKey !== null
            ? deserializeAws_json1_1EncryptionKey(output.EncryptionKey, context)
            : undefined,
        LastUpdatedAt: output.LastUpdatedAt !== undefined && output.LastUpdatedAt !== null
            ? new Date(Math.round(output.LastUpdatedAt * 1000))
            : undefined,
        Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
        SizeBytes: output.SizeBytes !== undefined && output.SizeBytes !== null ? output.SizeBytes : undefined,
        SourceLanguageCode: output.SourceLanguageCode !== undefined && output.SourceLanguageCode !== null
            ? output.SourceLanguageCode
            : undefined,
        TargetLanguageCodes: output.TargetLanguageCodes !== undefined && output.TargetLanguageCodes !== null
            ? deserializeAws_json1_1LanguageCodeStringList(output.TargetLanguageCodes, context)
            : undefined,
        TermCount: output.TermCount !== undefined && output.TermCount !== null ? output.TermCount : undefined,
    };
};
const deserializeAws_json1_1TerminologyPropertiesList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1TerminologyProperties(entry, context));
};
const deserializeAws_json1_1TermList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1Term(entry, context));
};
const deserializeAws_json1_1TextSizeLimitExceededException = (output, context) => {
    return {
        __type: "TextSizeLimitExceededException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1TextTranslationJobProperties = (output, context) => {
    return {
        __type: "TextTranslationJobProperties",
        DataAccessRoleArn: output.DataAccessRoleArn !== undefined && output.DataAccessRoleArn !== null
            ? output.DataAccessRoleArn
            : undefined,
        EndTime: output.EndTime !== undefined && output.EndTime !== null ? new Date(Math.round(output.EndTime * 1000)) : undefined,
        InputDataConfig: output.InputDataConfig !== undefined && output.InputDataConfig !== null
            ? deserializeAws_json1_1InputDataConfig(output.InputDataConfig, context)
            : undefined,
        JobDetails: output.JobDetails !== undefined && output.JobDetails !== null
            ? deserializeAws_json1_1JobDetails(output.JobDetails, context)
            : undefined,
        JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
        JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
        JobStatus: output.JobStatus !== undefined && output.JobStatus !== null ? output.JobStatus : undefined,
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
        OutputDataConfig: output.OutputDataConfig !== undefined && output.OutputDataConfig !== null
            ? deserializeAws_json1_1OutputDataConfig(output.OutputDataConfig, context)
            : undefined,
        SourceLanguageCode: output.SourceLanguageCode !== undefined && output.SourceLanguageCode !== null
            ? output.SourceLanguageCode
            : undefined,
        SubmittedTime: output.SubmittedTime !== undefined && output.SubmittedTime !== null
            ? new Date(Math.round(output.SubmittedTime * 1000))
            : undefined,
        TargetLanguageCodes: output.TargetLanguageCodes !== undefined && output.TargetLanguageCodes !== null
            ? deserializeAws_json1_1TargetLanguageCodeStringList(output.TargetLanguageCodes, context)
            : undefined,
        TerminologyNames: output.TerminologyNames !== undefined && output.TerminologyNames !== null
            ? deserializeAws_json1_1ResourceNameList(output.TerminologyNames, context)
            : undefined,
    };
};
const deserializeAws_json1_1TextTranslationJobPropertiesList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_json1_1TextTranslationJobProperties(entry, context));
};
const deserializeAws_json1_1TooManyRequestsException = (output, context) => {
    return {
        __type: "TooManyRequestsException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
    };
};
const deserializeAws_json1_1TranslateTextResponse = (output, context) => {
    return {
        __type: "TranslateTextResponse",
        AppliedTerminologies: output.AppliedTerminologies !== undefined && output.AppliedTerminologies !== null
            ? deserializeAws_json1_1AppliedTerminologyList(output.AppliedTerminologies, context)
            : undefined,
        SourceLanguageCode: output.SourceLanguageCode !== undefined && output.SourceLanguageCode !== null
            ? output.SourceLanguageCode
            : undefined,
        TargetLanguageCode: output.TargetLanguageCode !== undefined && output.TargetLanguageCode !== null
            ? output.TargetLanguageCode
            : undefined,
        TranslatedText: output.TranslatedText !== undefined && output.TranslatedText !== null ? output.TranslatedText : undefined,
    };
};
const deserializeAws_json1_1UnsupportedLanguagePairException = (output, context) => {
    return {
        __type: "UnsupportedLanguagePairException",
        Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
        SourceLanguageCode: output.SourceLanguageCode !== undefined && output.SourceLanguageCode !== null
            ? output.SourceLanguageCode
            : undefined,
        TargetLanguageCode: output.TargetLanguageCode !== undefined && output.TargetLanguageCode !== null
            ? output.TargetLanguageCode
            : undefined,
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    httpHeaders: output.headers,
    requestId: output.headers["x-amzn-requestid"],
});
// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
//# sourceMappingURL=Aws_json1_1.js.map